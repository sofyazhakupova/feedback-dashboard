<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App Review Analytics Dashboard</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --github-bg: #ffffff;
            --github-bg-secondary: #f6f8fa;
            --github-border: #d1d9e0;
            --github-border-light: #e1e4e8;
            --github-text: #24292f;
            --github-text-secondary: #656d76;
            --github-text-muted: #8b949e;
            --github-accent: #0969da;
            --github-accent-hover: #0860ca;
            --github-success: #1a7f37;
            --github-warning: #9a6700;
            --github-danger: #d1242f;
        }

        * {
            box-sizing: border-box;
        }

        body { 
            background: var(--github-bg);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            color: var(--github-text);
            line-height: 1.5;
            font-size: 14px;
        }

        .main-container {
            background: var(--github-bg);
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 16px;
            padding: 0;
            border: 1px solid var(--github-border);
        }

        /* Header */
        .header-section {
            background: var(--github-bg-secondary);
            color: var(--github-text);
            padding: 24px 0;
            margin-bottom: 0;
            border-bottom: 1px solid var(--github-border);
        }

        .header-title {
            color: var(--github-text);
            font-weight: 600;
            font-size: 24px;
            margin: 0;
        }

        .header-subtitle {
            color: var(--github-text-secondary);
            font-weight: 400;
            font-size: 16px;
            margin: 4px 0 0 0;
        }

        /* Navigation */
        .nav-tabs {
            border: none;
            background: var(--github-bg);
            padding: 0 16px;
            margin: 0;
        }

        .nav-tabs .nav-link {
            border: none;
            border-radius: 6px 6px 0 0;
            margin-right: 4px;
            background: transparent;
            color: var(--github-text-secondary);
            font-weight: 500;
            padding: 8px 16px;
            border-bottom: 2px solid transparent;
            transition: all 0.15s ease;
            font-size: 14px;
        }

        .nav-tabs .nav-link:hover {
            background: var(--github-bg-secondary);
            color: var(--github-text);
            border-bottom-color: var(--github-border);
        }

        .nav-tabs .nav-link.active {
            background: var(--github-bg);
            color: var(--github-text);
            border-bottom-color: var(--github-accent);
            font-weight: 600;
        }

        .tab-content {
            background: var(--github-bg);
            border-radius: 0;
            padding: 24px;
            box-shadow: none;
            border: none;
        }

        /* Cards */
        .metric-card { 
            background: var(--github-bg);
            color: var(--github-text);
            border-radius: 6px;
            border: 1px solid var(--github-border);
            transition: all 0.15s ease;
            padding: 16px;
        }

        .metric-card:hover {
            border-color: var(--github-border-light);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .metric-card h2 { 
            font-size: 24px; 
            font-weight: 600;
            color: var(--github-text);
            margin: 0;
        }

        .metric-card h4 {
            font-weight: 500;
            color: var(--github-text-secondary);
            font-size: 14px;
            margin: 0 0 8px 0;
        }

        .chart-card {
            border-radius: 6px;
            box-shadow: none;
            border: 1px solid var(--github-border);
        }

        .chart-header {
            background: var(--github-bg-secondary);
            color: var(--github-text);
            border-radius: 6px 6px 0 0;
            padding: 12px 16px;
            border-bottom: 1px solid var(--github-border);
        }

        .chart-header h5 {
            font-weight: 600;
            font-size: 14px;
            margin: 0;
            color: var(--github-text);
        }

        /* Filters */
        .filter-section {
            background: var(--github-bg-secondary);
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--github-border);
        }

        .filter-section h5 {
            font-weight: 600;
            color: var(--github-text);
            font-size: 14px;
            margin: 0 0 12px 0;
        }

        /* Buttons */
        .btn {
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
            padding: 6px 12px;
            border: 1px solid var(--github-border);
            transition: all 0.15s ease;
        }

        .btn-primary {
            background: var(--github-accent);
            color: white;
            border-color: var(--github-accent);
        }

        .btn-primary:hover {
            background: var(--github-accent-hover);
            border-color: var(--github-accent-hover);
        }

        .btn-outline-primary {
            background: transparent;
            color: var(--github-accent);
            border-color: var(--github-accent);
        }

        .btn-outline-primary:hover {
            background: var(--github-accent);
            color: white;
        }

        .btn-outline-secondary {
            background: transparent;
            color: var(--github-text-secondary);
            border-color: var(--github-border);
        }

        .btn-outline-secondary:hover {
            background: var(--github-bg-secondary);
            border-color: var(--github-border-light);
        }

        .btn-outline-danger {
            background: transparent;
            color: var(--github-danger);
            border-color: var(--github-danger);
        }

        .btn-outline-danger:hover {
            background: var(--github-danger);
            color: white;
        }

        /* Source Cards */
        .source-card {
            background: var(--github-bg);
            border-radius: 6px;
            padding: 16px;
            text-align: center;
            transition: all 0.15s ease;
            border: 1px solid var(--github-border);
        }

        .source-card:hover {
            border-color: var(--github-border-light);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .source-card.active {
            border-color: var(--github-accent);
            background: var(--github-bg-secondary);
        }

        .source-card.inactive {
            border-color: var(--github-border);
            background: var(--github-bg-secondary);
            opacity: 0.6;
        }

        .add-source-card {
            border: 2px dashed var(--github-border);
            background: var(--github-bg-secondary);
            color: var(--github-text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .add-source-card:hover {
            background: var(--github-accent);
            color: white;
            border-color: var(--github-accent);
        }

        /* Tables */
        .data-table {
            background: var(--github-bg);
            border-radius: 6px;
            overflow: hidden;
            box-shadow: none;
            border: 1px solid var(--github-border);
        }

        .table th {
            background: var(--github-bg-secondary);
            color: var(--github-text);
            border: none;
            font-weight: 600;
            font-size: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid var(--github-border);
        }

        .table td {
            border-color: var(--github-border);
            vertical-align: middle;
            padding: 12px 16px;
            font-size: 14px;
        }

        .table-hover tbody tr:hover {
            background-color: var(--github-bg-secondary);
        }

        /* Badges */
        .badge {
            border-radius: 12px;
            font-weight: 500;
            font-size: 12px;
            padding: 4px 8px;
        }

        .badge-source {
            background: var(--github-accent);
            color: white;
        }

        /* Form Controls */
        .form-control, .form-select {
            border-radius: 6px;
            border: 1px solid var(--github-border);
            padding: 8px 12px;
            font-weight: 400;
            font-size: 14px;
        }

        .form-control:focus, .form-select:focus {
            border-color: var(--github-accent);
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }

        /* Alerts */
        .alert {
            border-radius: 0;
            border: 1px solid var(--light-gray);
            font-weight: 400;
        }

        .alert-info {
            background: var(--secondary-white);
            color: var(--primary-black);
            border-color: var(--light-gray);
        }

        /* Modal */
        .modal-content {
            border-radius: 8px;
            border: 1px solid var(--github-border);
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
        }

        .modal-header {
            background: var(--github-bg-secondary);
            color: var(--github-text);
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid var(--github-border);
        }

        .modal-header h5 {
            font-weight: 600;
            font-size: 16px;
        }

        .btn-close-white {
            filter: none;
        }

        .alert-warning {
            background-color: #fff8c5;
            border-color: #f0cc00;
            color: #9a6700;
        }

        /* Pagination */
        .pagination .page-link {
            border-radius: 0;
            border: 1px solid var(--light-gray);
            color: var(--primary-black);
            padding: 0.75rem 1rem;
        }

        .pagination .page-link:hover {
            background: var(--secondary-white);
            border-color: var(--primary-black);
        }

        .pagination .page-item.active .page-link {
            background: var(--primary-black);
            border-color: var(--primary-black);
        }

        /* Footer */
        .footer-section {
            background: var(--secondary-white);
            border-top: 1px solid var(--light-gray);
            padding: 2rem;
            margin-top: 2rem;
        }

        .footer-section p {
            color: var(--medium-gray);
            font-weight: 300;
            font-size: 0.9rem;
        }

        /* Live indicator */
        .live-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header-title {
                font-size: 2rem;
            }
            
            .tab-content {
                padding: 1rem;
            }
            
            .filter-section {
                padding: 1rem;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary-white);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-black);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-black);
        }

        /* Sortable column styles */
        .sortable {
            position: relative;
            transition: background-color 0.2s ease;
        }

        .sortable:hover {
            background-color: rgba(0, 123, 255, 0.1);
        }

        .sort-arrow {
            margin-left: 3px;
            font-size: 0.8em;
            opacity: 0.6;
            transition: opacity 0.2s ease;
        }

        .sortable:hover .sort-arrow {
            opacity: 1;
        }

        .sort-arrow.active {
            opacity: 1;
            font-weight: bold;
        }

        .sort-arrow.asc::after {
            content: " ↑";
        }

        .sort-arrow.desc::after {
            content: " ↓";
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header-section">
            <div class="container">
                <div class="row">
                    <div class="col-12 text-center">
                        <h1 class="header-title mb-3">
                            <i class="fas fa-chart-line me-3"></i>
                            App Review Analytics
                        </h1>
                        <p class="header-subtitle">
                            <i class="fas fa-sync-alt live-indicator me-2"></i>
                            Real-time insights from app stores, support tickets, and surveys
                            <span id="pendingIndicator" class="ms-3" style="display: none;">
                                <span class="badge bg-warning text-dark">
                                    <i class="fas fa-exclamation-triangle me-1"></i>
                                    <span id="pendingCountBadge">0</span> feedbacks need review
                                </span>
                            </span>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation Tabs -->
        <ul class="nav nav-tabs" id="dashboardTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dashboard-tab" data-bs-toggle="tab" data-bs-target="#dashboard" type="button" role="tab">
                    <i class="fas fa-chart-pie me-2"></i>Dashboard
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="list-tab" data-bs-toggle="tab" data-bs-target="#list" type="button" role="tab">
                    <i class="fas fa-list me-2"></i>Feedback List
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="keywords-tab" data-bs-toggle="tab" data-bs-target="#keywords" type="button" role="tab">
                    <i class="fas fa-tags me-2"></i>Keywords
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="sources-tab" data-bs-toggle="tab" data-bs-target="#sources" type="button" role="tab">
                    <i class="fas fa-cog me-2"></i>Data Sources
                </button>
            </li>
        </ul>

        <!-- Tab Content -->
        <div class="tab-content" id="dashboardTabsContent">
            
            <!-- Dashboard Tab -->
            <div class="tab-pane fade show active" id="dashboard" role="tabpanel">
                
                <!-- Time Period Selector -->
                <div class="filter-section">
                    <div class="row align-items-center">
                        <div class="col-md-6">
                            <h5 class="mb-0">
                                <i class="fas fa-calendar-alt me-2"></i>
                                Time Period
                            </h5>
                        </div>
                        <div class="col-md-6">
                            <div class="btn-group w-100" role="group">
                                <input type="radio" class="btn-check" name="timePeriod" id="last7days" value="7">
                                <label class="btn btn-outline-primary" for="last7days">Last 7 days</label>

                                <input type="radio" class="btn-check" name="timePeriod" id="lastMonth" value="30">
                                <label class="btn btn-outline-primary" for="lastMonth">Last month</label>

                                <input type="radio" class="btn-check" name="timePeriod" id="last3Months" value="90">
                                <label class="btn btn-outline-primary" for="last3Months">3 months</label>

                                <input type="radio" class="btn-check" name="timePeriod" id="last6Months" value="180">
                                <label class="btn btn-outline-primary" for="last6Months">6 months</label>

                                <input type="radio" class="btn-check" name="timePeriod" id="lastYear" value="365">
                                <label class="btn btn-outline-primary" for="lastYear">1 year</label>

                                <input type="radio" class="btn-check" name="timePeriod" id="allTime" value="0" checked>
                                <label class="btn btn-outline-primary" for="allTime">All time</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Metrics Row -->
                <div class="row mb-4">
                    <div class="col-lg-3 col-md-6 mb-4">
                        <div class="card metric-card h-100">
                            <div class="card-body text-center">
                                <i class="fas fa-star fa-2x mb-3" style="color: var(--primary-black);"></i>
                                <h4 class="card-title">Avg Rating (3M)</h4>
                                <h2 id="total-avg-rating">0.0</h2>
                                <small style="color: var(--medium-gray);" id="total-rating-change">No change</small>
                                <div id="total-rating-trend" style="height: 40px; margin-top: 8px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-3 col-md-6 mb-4">
                        <div class="card metric-card h-100">
                            <div class="card-body text-center">
                                <i class="fab fa-google-play fa-2x mb-3" style="color: var(--primary-black);"></i>
                                <h4 class="card-title">Google Play (3M)</h4>
                                <h2 id="playstore-avg-rating">0.0</h2>
                                <small style="color: var(--medium-gray);" id="playstore-rating-change">No change</small>
                                <div id="playstore-rating-trend" style="height: 40px; margin-top: 8px;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-3 col-md-6 mb-4">
                        <div class="card metric-card h-100">
                            <div class="card-body text-center">
                                <i class="fab fa-apple fa-2x mb-3" style="color: var(--primary-black);"></i>
                                <h4 class="card-title">Apple Store (3M)</h4>
                                <h2 id="appstore-avg-rating">0.0</h2>
                                <small style="color: var(--medium-gray);" id="appstore-rating-change">No change</small>
                                <div id="appstore-rating-trend" style="height: 40px; margin-top: 8px;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Combined Keywords and Trends -->
                <div class="row mb-5">
                    <div class="col-12">
                        <div class="card chart-card">
                            <div class="card-header">
                                <div class="row align-items-center">
                                    <div class="col-md-6">
                                        <h5 class="mb-0">
                                            <i class="fas fa-chart-line me-2"></i>
                                            Keyword Trends & Analysis
                                        </h5>
                                        <small class="text-muted">Select keywords to analyze trends over time (max 5)</small>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="d-flex justify-content-end">
                                            <button class="btn btn-sm btn-outline-secondary" onclick="showKeywordsTab()" title="Manage Keywords">
                                                <i class="fas fa-cog"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="card-body">
                                <!-- Keyword Selection List -->
                                <div class="row mb-4">
                                    <div class="col-md-8">
                                        <div class="mb-3">
                                            <label class="form-label">
                                                <i class="fas fa-search me-2"></i>Search Keywords
                                            </label>
                                            <input type="text" class="form-control" id="keywordSearchInput" placeholder="Search keywords..." onkeyup="filterKeywords()">
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="mb-3">
                                            <label class="form-label">
                                                <i class="fas fa-cog me-2"></i>Step Size
                                            </label>
                                            <select class="form-select" id="stepSizeSelector" onchange="updateKeywordTrends()">
                                                <option value="day">Daily</option>
                                                <option value="week" selected>Weekly</option>
                                                <option value="month">Monthly</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Keywords List with Checkboxes and Pagination -->
                                <div class="mb-4">
                                    <div class="d-flex justify-content-between align-items-center mb-2">
                                        <label class="form-label mb-0">
                                            <i class="fas fa-check-square me-2"></i>Select Keywords (max 5)
                                            <span class="badge bg-secondary ms-2" id="selectedKeywordsCount">0</span>
                                        </label>
                                        <div class="btn-group btn-group-sm" role="group" id="keywordsPagination">
                                            <!-- Pagination buttons will be added here -->
                                        </div>
                                    </div>
                                    <div id="keywordsList" class="border rounded p-3" style="max-height: 200px; overflow-y: auto;">
                                        <p class="text-muted text-center">No keywords available</p>
                                    </div>
                                </div>
                                
                                <!-- Trend Chart -->
                                <div id="keywordTrendsChart" style="height: 400px;">
                                    <!-- Chart will be rendered here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Lists Row -->
                <div class="row mb-4">
                    <div class="col-lg-4 col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-exclamation-triangle me-2" style="color: #dc3545;"></i>
                                    Pain Points (Top 10)
                                </h5>
                            </div>
                            <div class="card-body">
                                <div id="painPointsList">
                                    <p class="text-muted">No pain points identified</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-thumbs-up me-2" style="color: #28a745;"></i>
                                    Advantages (Top 10)
                                </h5>
                            </div>
                            <div class="card-body">
                                <div id="advantagesList">
                                    <p class="text-muted">No advantages identified</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-4 col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-lightbulb me-2" style="color: #ffc107;"></i>
                                    Requested Features (Top 10)
                                </h5>
                            </div>
                            <div class="card-body">
                                <div id="requestedFeaturesList">
                                    <p class="text-muted">No feature requests identified</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pie Charts Row -->
                <div class="row mb-4">
                    <div class="col-lg-6 mb-4">
                        <div class="card chart-card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-chart-pie me-2"></i>
                                    Pain Points Distribution
                                </h5>
                            </div>
                            <div class="card-body">
                                <div id="painPointsChart" style="height: 350px;">
                                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                                        <div class="text-center">
                                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                                            <p>No data available</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-6 mb-4">
                        <div class="card chart-card h-100">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-chart-pie me-2"></i>
                                    Requested Features Distribution
                                </h5>
                            </div>
                            <div class="card-body">
                                <div id="requestedFeaturesChart" style="height: 350px;">
                                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                                        <div class="text-center">
                                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                                            <p>No data available</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Rating and Trends -->
                <div class="row mb-5">
                    <div class="col-lg-6 mb-4">
                        <div class="card chart-card h-100">
                            <div class="chart-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-star me-2"></i>
                                    Rating Distribution
                                </h5>
                            </div>
                            <div class="card-body p-4">
                                <div id="rating-chart" style="height: 350px;">
                                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                                        <div class="text-center">
                                            <i class="fas fa-star fa-3x mb-3"></i>
                                            <p>No data available</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-6 mb-4">
                        <div class="card chart-card h-100">
                            <div class="chart-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-chart-line me-2"></i>
                                    Trends Over Time
                                </h5>
                            </div>
                            <div class="card-body p-4">
                                <div id="trends-chart" style="height: 350px;">
                                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                                        <div class="text-center">
                                            <i class="fas fa-chart-line fa-3x mb-3"></i>
                                            <p>No data available</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Feedback List Tab -->
            <div class="tab-pane fade" id="list" role="tabpanel">
                <h4 class="mb-4" style="font-weight: 600; font-size: 20px;">
                    <i class="fas fa-list me-2"></i>
                    All Feedback
                </h4>

                <!-- Time Period Selector for List -->
                <div class="filter-section">
                    <div class="row align-items-center">
                        <div class="col-md-6">
                            <div class="d-flex align-items-center">
                                <h5 class="mb-0 me-3">
                                    <i class="fas fa-calendar-alt me-2"></i>
                                    Time Period
                                </h5>
                                <div class="dropdown">
                                    <button class="btn btn-outline-secondary btn-sm" type="button" id="customDateRangeDropdown" data-bs-toggle="dropdown" aria-expanded="false" title="Custom Date Range">
                                        <i class="fas fa-calendar-day"></i>
                                    </button>
                                    <div class="dropdown-menu p-3" style="min-width: 300px;">
                                        <h6 class="dropdown-header">Custom Date Range</h6>
                                        <div class="row mb-2">
                                            <div class="col-6">
                                                <label class="form-label small">Start Date</label>
                                                <input type="date" class="form-control form-control-sm" id="startDate">
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label small">End Date</label>
                                                <input type="date" class="form-control form-control-sm" id="endDate">
                                            </div>
                                        </div>
                                        <div class="d-flex gap-2">
                                            <button class="btn btn-primary btn-sm" onclick="applyCustomDateRange()">Apply</button>
                                            <button class="btn btn-outline-secondary btn-sm" onclick="clearCustomDateRange()">Clear</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="btn-group w-100" role="group">
                                <input type="radio" class="btn-check" name="timePeriodList" id="last7daysList" value="7">
                                <label class="btn btn-outline-primary" for="last7daysList">Last 7 days</label>

                                <input type="radio" class="btn-check" name="timePeriodList" id="lastMonthList" value="30">
                                <label class="btn btn-outline-primary" for="lastMonthList">Last month</label>

                                <input type="radio" class="btn-check" name="timePeriodList" id="last3MonthsList" value="90">
                                <label class="btn btn-outline-primary" for="last3MonthsList">3 months</label>

                                <input type="radio" class="btn-check" name="timePeriodList" id="last6MonthsList" value="180">
                                <label class="btn btn-outline-primary" for="last6MonthsList">6 months</label>

                                <input type="radio" class="btn-check" name="timePeriodList" id="lastYearList" value="365">
                                <label class="btn btn-outline-primary" for="lastYearList">1 year</label>

                                <input type="radio" class="btn-check" name="timePeriodList" id="allTimeList" value="0" checked>
                                <label class="btn btn-outline-primary" for="allTimeList">All time</label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="filter-section">
                    <div class="row">
                        <div class="col-md-3 mb-3">
                            <label class="form-label">Source Filter</label>
                            <select class="form-select" id="sourceFilter">
                                <option value="">All Sources</option>
                            </select>
                        </div>
                        <div class="col-md-3 mb-3">
                            <label class="form-label">User Type</label>
                            <select class="form-select" id="userTypeFilter">
                                <option value="">All Users</option>
                                <option value="premium">Premium Users</option>
                                <option value="free">Free Users</option>
                                <option value="unknown">Unknown</option>
                            </select>
                        </div>
                        <div class="col-md-3 mb-3">
                            <label class="form-label">Rating Filter</label>
                            <select class="form-select" id="ratingFilter">
                                <option value="">All Ratings</option>
                                <option value="5">5 Stars</option>
                                <option value="4">4 Stars</option>
                                <option value="3">3 Stars</option>
                                <option value="2">2 Stars</option>
                                <option value="1">1 Star</option>
                            </select>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12 mb-3 d-flex justify-content-end">
                            <button class="btn btn-outline-secondary" onclick="clearFilters()">
                                <i class="fas fa-times me-2"></i>Clear All Filters
                            </button>
                        </div>
                    </div>
                    
                    <!-- Keyword Tags Cloud -->
                    <div class="row mt-3">
                        <div class="col-12">
                            <label class="form-label">
                                Quick Keyword Filters 
                                <button class="btn btn-sm btn-outline-primary ms-2" onclick="showKeywordsTab()" title="Manage Keywords">
                                    <i class="fas fa-cog"></i>
                                </button>
                            </label>
                            <div id="keywordTags" class="mb-3">
                                <span class="badge bg-light text-dark me-2 mb-2" style="cursor: pointer; border: 1px solid var(--light-gray);" onclick="addKeywordFilter('')">
                                    <i class="fas fa-times me-1"></i>Clear All
                                </span>
                                <!-- Managed keywords will be dynamically added here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Results Summary -->
                <div class="row mb-3">
                    <div class="col-12">
                        <div class="alert alert-info d-flex justify-content-between align-items-center">
                            <div class="d-flex align-items-center">
                                <i class="fas fa-info-circle me-2"></i>
                                Showing <strong id="resultsCount">0</strong> reviews
                                <span id="filterSummary" class="ms-3"></span>
                            </div>
                            <div class="d-flex align-items-center">
                                <label class="form-label me-2 mb-0">
                                    Search
                                    <button class="btn btn-sm btn-outline-primary ms-2" onclick="showKeywordsTab()" title="Manage Keywords">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </label>
                                <input type="text" class="form-control" id="keywordSearch" placeholder="Search reviews..." style="width: 200px;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Pending Feedbacks Notification -->
                <div id="pendingReviewsAlert" class="row mb-3" style="display: none;">
                    <div class="col-12">
                        <div class="alert alert-warning">
                            <i class="fas fa-clock me-2"></i>
                            <strong id="pendingReviewsCount">0</strong> feedbacks are waiting for review
                            <span class="ms-2 text-muted">These feedbacks were skipped during upload and need manual review before being added to the system.</span>
                            <button class="btn btn-sm btn-outline-warning ms-3" onclick="showPendingReviews()">
                                <i class="fas fa-eye me-1"></i>Review Feedbacks
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Reviews Table -->
                <div class="data-table">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortByColumn('date')" style="cursor: pointer; user-select: none;">
                                        Date<span id="date-sort-arrow" class="sort-arrow">↕</span>
                                    </th>
                                    <th>Source</th>
                                    <th>User Name</th>
                                    <th>User Type</th>
                                    <th>Message</th>
                                    <th class="sortable" onclick="sortByColumn('rating')" style="cursor: pointer; user-select: none;">
                                        Rating<span id="rating-sort-arrow" class="sort-arrow">↕</span>
                                    </th>
                                    <th>Keywords</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="reviewsTableBody">
                                <tr>
                                    <td colspan="8" class="text-center" style="color: var(--medium-gray); padding: 3rem;">
                                        <i class="fas fa-database fa-3x mb-3"></i>
                                        <p>No data loaded. Upload CSV files in the Data Sources tab.</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Pagination Controls -->
                <div class="d-flex justify-content-between align-items-center mt-3">
                    <div class="d-flex align-items-center">
                        <span class="text-muted me-3">Show:</span>
                        <select id="pageSizeSelect" class="form-select form-select-sm" style="width: auto;" onchange="changePageSize()">
                            <option value="25">25</option>
                            <option value="50" selected>50</option>
                            <option value="100">100</option>
                            <option value="200">200</option>
                        </select>
                        <span class="text-muted ms-2">per page</span>
                    </div>
                    <div class="d-flex align-items-center">
                        <span id="paginationInfo" class="text-muted me-3">Showing 1-50 of 0</span>
                        <nav>
                            <ul class="pagination pagination-sm mb-0" id="paginationControls">
                                <!-- Pagination buttons will be generated here -->
                            </ul>
                        </nav>
                    </div>
                </div>
            </div>

            <!-- Keywords Tab -->
            <div class="tab-pane fade" id="keywords" role="tabpanel">
                <div class="container-fluid mt-4">
                    <div class="row mb-4">
                        <div class="col-md-8">
                            <h4>
                                <i class="fas fa-tags me-2"></i>
                                Keywords Manager - Golf App Analysis
                            </h4>
                            <p class="text-muted">Manage keywords for competitor tracking, golf features, and feature requests. Smart suggestions help you discover new keywords from your reviews.</p>
                        </div>
                        <div class="col-md-4 text-end">
                            <button class="btn btn-primary" onclick="updateSmartSuggestions()">
                                <i class="fas fa-refresh me-2"></i>Update Suggestions
                            </button>
                        </div>
                    </div>

                    <!-- Keywords Categories -->
                    <div class="row">
                        <!-- Competitors -->
                        <div class="col-md-4 mb-4">
                            <div class="card h-100">
                                <div class="card-header bg-danger text-white">
                                    <h6 class="mb-0">
                                        <i class="fas fa-trophy me-2"></i>
                                        Competitors
                                    </h6>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <div class="input-group input-group-sm">
                                            <input type="text" class="form-control" id="newCompetitorKeyword" placeholder="Add competitor name...">
                                            <button class="btn btn-outline-danger" onclick="addKeyword('competitors', 'newCompetitorKeyword')">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="competitorsKeywords" class="mb-2">
                                        <!-- Competitors keywords will be added here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Golf Features -->
                        <div class="col-md-4 mb-4">
                            <div class="card h-100">
                                <div class="card-header bg-success text-white">
                                    <h6 class="mb-0">
                                        <i class="fas fa-golf-ball me-2"></i>
                                        Golf Features
                                    </h6>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <div class="input-group input-group-sm">
                                            <input type="text" class="form-control" id="newGolfFeatureKeyword" placeholder="Add golf feature...">
                                            <button class="btn btn-outline-success" onclick="addKeyword('golfFeatures', 'newGolfFeatureKeyword')">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="golfFeaturesKeywords" class="mb-2">
                                        <!-- Golf features keywords will be added here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Feature Requests -->
                        <div class="col-md-4 mb-4">
                            <div class="card h-100">
                                <div class="card-header bg-warning text-dark">
                                    <h6 class="mb-0">
                                        <i class="fas fa-lightbulb me-2"></i>
                                        Feature Requests
                                    </h6>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <div class="input-group input-group-sm">
                                            <input type="text" class="form-control" id="newFeatureRequestKeyword" placeholder="Add feature request...">
                                            <button class="btn btn-outline-warning" onclick="addKeyword('featureRequests', 'newFeatureRequestKeyword')">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div id="featureRequestsKeywords" class="mb-2">
                                        <!-- Feature requests keywords will be added here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Smart Suggestions -->
                    <div class="row">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">
                                    <h6 class="mb-0">
                                        <i class="fas fa-magic me-2"></i>
                                        Smart Suggestions from Reviews
                                    </h6>
                                    <small class="text-muted">Keywords automatically detected from your review content</small>
                                </div>
                                <div class="card-body">
                                    <div class="row">
                                        <div class="col-md-4">
                                            <h6 class="text-danger">Potential Competitors:</h6>
                                            <div id="suggestedCompetitors" class="mb-3">
                                                <p class="text-muted small">Upload reviews to get suggestions</p>
                                            </div>
                                        </div>
                                        <div class="col-md-4">
                                            <h6 class="text-success">Golf Terms:</h6>
                                            <div id="suggestedGolfTerms" class="mb-3">
                                                <p class="text-muted small">Upload reviews to get suggestions</p>
                                            </div>
                                        </div>
                                        <div class="col-md-4">
                                            <h6 class="text-warning">Feature Mentions:</h6>
                                            <div id="suggestedFeatures" class="mb-3">
                                                <p class="text-muted small">Upload reviews to get suggestions</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Pain Points Analysis -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">
                                    <h6 class="mb-0">
                                        <i class="fas fa-exclamation-triangle me-2"></i>
                                        Pain Points Analysis
                                    </h6>
                                    <small class="text-muted">Intelligent analysis of user frustrations and issues</small>
                                </div>
                                <div class="card-body">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <h6 class="text-danger">Critical Issues:</h6>
                                            <div id="criticalPainPoints" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze pain points</p>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h6 class="text-warning">Feature Problems:</h6>
                                            <div id="featurePainPoints" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze pain points</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="row">
                                        <div class="col-md-6">
                                            <h6 class="text-info">Performance Issues:</h6>
                                            <div id="performancePainPoints" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze pain points</p>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h6 class="text-secondary">User Experience Issues:</h6>
                                            <div id="uxPainPoints" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze pain points</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Advantages Analysis -->
                    <div class="row mt-4">
                        <div class="col-12">
                            <div class="card">
                                <div class="card-header">
                                    <h6 class="mb-0">
                                        <i class="fas fa-thumbs-up me-2"></i>
                                        Advantages Analysis
                                    </h6>
                                    <small class="text-muted">What users appreciate and love about your app</small>
                                </div>
                                <div class="card-body">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <h6 class="text-success">Feature Strengths:</h6>
                                            <div id="featureAdvantages" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze advantages</p>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h6 class="text-primary">Performance Strengths:</h6>
                                            <div id="performanceAdvantages" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze advantages</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="row">
                                        <div class="col-md-6">
                                            <h6 class="text-info">User Experience Strengths:</h6>
                                            <div id="uxAdvantages" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze advantages</p>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <h6 class="text-warning">Competitive Advantages:</h6>
                                            <div id="competitiveAdvantages" class="mb-3">
                                                <p class="text-muted small">Upload reviews to analyze advantages</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <!-- Data Sources Tab -->
            <div class="tab-pane fade" id="sources" role="tabpanel">
                <div class="row mb-4">
                    <div class="col-md-8">
                        <h4 class="mb-0" style="font-weight: 300;">
                            <i class="fas fa-cog me-2"></i>
                            Data Sources Management
                            <span class="badge bg-secondary ms-2" id="sources-count">0</span>
                        </h4>
                        <p style="color: var(--medium-gray);">Configure and manage your data sources</p>
                    </div>
                    <div class="col-md-4 text-end">
                        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addSourceModal">
                            <i class="fas fa-plus me-2"></i>Add New Source
                        </button>
                        <button class="btn btn-outline-danger ms-2" onclick="clearAllData()">
                            <i class="fas fa-trash me-2"></i>Clear All Data
                        </button>
                    </div>
                </div>

                <!-- Existing Sources -->
                <div class="row mb-4" id="sourcesContainer">
                    <!-- Sources will be dynamically added here -->
                </div>

                <!-- Add New Source Placeholder -->
                <div class="row">
                    <div class="col-lg-3 col-md-6 mb-3">
                        <div class="source-card add-source-card" data-bs-toggle="modal" data-bs-target="#addSourceModal">
                            <i class="fas fa-plus fa-3x mb-3"></i>
                            <h6 class="fw-bold">Add New Source</h6>
                            <p class="small mb-0">Click to add CSV file or API source</p>
                        </div>
                    </div>
                </div>

                <!-- Source Configuration Help -->
                <div class="row mt-4">
                    <div class="col-12">
                        <div class="card" style="border: 1px solid var(--light-gray);">
                            <div class="card-header" style="background: var(--secondary-white); border-bottom: 1px solid var(--light-gray);">
                                <h5 class="mb-0" style="font-weight: 400;">
                                    <i class="fas fa-question-circle me-2"></i>
                                    Source Configuration Guide
                                </h5>
                            </div>
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-md-6">
                                        <h6 style="font-weight: 400;">Supported File Formats</h6>
                                        <ul class="list-unstyled">
                                            <li><i class="fas fa-check me-2" style="color: var(--primary-black);"></i>CSV Files (.csv)</li>
                                            <li><i class="fas fa-check me-2" style="color: var(--primary-black);"></i>Excel Files (.xlsx)</li>
                                            <li><i class="fas fa-check me-2" style="color: var(--primary-black);"></i>JSON Files (.json)</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-6">
                                        <h6 style="font-weight: 400;">Required CSV Columns</h6>
                                        <ul class="list-unstyled">
                                            <li><i class="fas fa-info-circle me-2" style="color: var(--medium-gray);"></i>date, source, content</li>
                                            <li><i class="fas fa-info-circle me-2" style="color: var(--medium-gray);"></i>rating, author, sentiment</li>
                                            <li><i class="fas fa-info-circle me-2" style="color: var(--medium-gray);"></i>category, metadata (optional)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer-section">
            <div class="row">
                <div class="col-12 text-center">
                    <p class="mb-2">
                        <strong>App Review Analytics Dashboard</strong> | 
                        <i class="fas fa-sync-alt live-indicator me-1"></i>
                        Live Data | 
                        Last Updated: <span id="last-updated"></span>
                    </p>
                    <p class="small">
                        <i class="fas fa-share-alt me-1"></i>
                        Share this dashboard with your team: 
                        <strong>https://yourusername.github.io/app-review-dashboard/</strong>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Source Modal -->
    <div class="modal fade" id="addSourceModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-plus me-2"></i>
                        Add New Data Source
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="addSourceForm">
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Source Type</label>
                                <select class="form-select" id="sourceType" required>
                                    <option value="csv" selected>CSV Upload</option>
                                    <option value="excel">Excel File</option>
                                    <option value="json">JSON File</option>
                                    <option value="api">API Integration</option>
                                </select>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Source Name</label>
                                <input type="text" class="form-control" id="sourceName" placeholder="e.g., Customer Reviews" required>
                            </div>
                        </div>
                        
                        <div id="fileConfig">
                            <h6 class="mb-3" style="font-weight: 400;">File Configuration</h6>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Upload File</label>
                                    <input type="file" class="form-control" id="fileUpload" accept=".csv,.xlsx,.json" required>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">File Format</label>
                                    <select class="form-select" id="fileFormat">
                                        <option value="csv">CSV</option>
                                        <option value="excel">Excel</option>
                                        <option value="json">JSON</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div id="apiConfig" style="display: none;">
                            <h6 class="mb-3" style="font-weight: 400;">API Configuration</h6>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">API URL</label>
                                    <input type="url" class="form-control" id="apiUrl" placeholder="https://api.example.com/endpoint">
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">API Key</label>
                                    <input type="password" class="form-control" id="apiKey" placeholder="Your API key">
                                </div>
                            </div>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Update Frequency</label>
                                    <select class="form-select" id="updateFrequency">
                                        <option value="hourly">Every Hour</option>
                                        <option value="daily">Daily</option>
                                        <option value="weekly">Weekly</option>
                                        <option value="manual">Manual Only</option>
                                    </select>
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label class="form-label">Data Limit</label>
                                    <input type="number" class="form-control" id="dataLimit" placeholder="100" value="100">
                                </div>
                            </div>
                        </div>

                        <div class="mb-3">
                            <label class="form-label">Description</label>
                            <textarea class="form-control" id="sourceDescription" rows="3" placeholder="Describe this data source..."></textarea>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveSource()">
                        <i class="fas fa-save me-2"></i>Save Source
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Review Modal -->
    <div class="modal fade" id="reviewModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Data Review Required
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-warning">
                        <i class="fas fa-info-circle me-2"></i>
                        <span id="reviewMessage">Some feedbacks couldn't be automatically processed and need your review.</span>
                        <div class="mt-2">
                            <small class="text-muted">
                                <span id="pendingCount">0</span> feedbacks need to be reviewed • 
                                Fill out the required fields (date and content) and click Save, or delete feedbacks you don't want to include
                                <br><strong>Column Assignment Help:</strong> If data appears in the wrong column, move it to the correct field below
                            </small>
                        </div>
                    </div>
                    
                    <div id="reviewContainer">
                        <!-- Review items will be dynamically added here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" onclick="skipAllReviews()">
                        <i class="fas fa-times me-2"></i>Skip All
                    </button>
                    <button type="button" class="btn btn-primary" onclick="saveReviews()">
                        <i class="fas fa-save me-2"></i>Save
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- View/Edit Review Modal -->
    <div class="modal fade" id="viewEditModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="fas fa-edit me-2"></i>
                        View & Edit Review
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="viewEditForm">
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Date <span class="text-danger">*</span></label>
                                <input type="date" class="form-control" id="editDate" required>
                                <small class="text-muted">Required: When the review was written</small>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Source</label>
                                <input type="text" class="form-control" id="editSource" placeholder="e.g., app_store, google_play">
                                <small class="text-muted">Where the review came from (app store, support, etc.)</small>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Author/User Name</label>
                                <input type="text" class="form-control" id="editAuthor" placeholder="User name or Anonymous">
                                <small class="text-muted">Name of the person who wrote the review</small>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label class="form-label">Rating</label>
                                <select class="form-select" id="editRating">
                                    <option value="">No rating</option>
                                    <option value="1">1 star</option>
                                    <option value="2">2 stars</option>
                                    <option value="3">3 stars</option>
                                    <option value="4">4 stars</option>
                                    <option value="5">5 stars</option>
                                </select>
                                <small class="text-muted">Star rating (1-5) - should be a number only</small>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-12 mb-3">
                                <label class="form-label">Message/Content <span class="text-danger">*</span></label>
                                <textarea class="form-control" id="editContent" rows="4" placeholder="Review content..." required></textarea>
                                <small class="text-muted">Required: The actual review text or comment</small>
                            </div>
                        </div>
                        
                        <!-- Review Info -->
                        <div class="alert alert-info">
                            <i class="fas fa-info-circle me-2"></i>
                            <strong>Review Information:</strong>
                            <div class="mt-2">
                                <small>
                                    <span id="editReviewInfo"></span>
                                </small>
                            </div>
                        </div>
                        
                        <!-- User Type and Keywords -->
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6 class="mb-0">
                                            <i class="fas fa-user-tag me-2"></i>
                                            User Type
                                        </h6>
                                    </div>
                                    <div class="card-body">
                                        <div class="mb-3">
                                            <label class="form-label">User Type</label>
                                            <select class="form-select" id="editUserType">
                                                <option value="unknown">Unknown</option>
                                                <option value="free">Free User</option>
                                                <option value="premium">Premium User</option>
                                            </select>
                                            <small class="text-muted">You can override the system's analysis</small>
                                        </div>
                                        <div id="editUserTypeAnalysis"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header">
                                        <h6 class="mb-0">
                                            <i class="fas fa-tags me-2"></i>
                                            Keywords Cloud
                                        </h6>
                                    </div>
                                    <div class="card-body">
                                        <div id="editKeywordsCloud"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-danger" onclick="deleteReview()">
                        <i class="fas fa-trash me-2"></i>Delete Review
                    </button>
                    <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" onclick="saveEditedReview()">
                        <i class="fas fa-save me-2"></i>Save Changes
                    </button>
                </div>
            </div>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global data storage
        let allReviews = [];
        let dataSources = [];
        let pendingReviews = []; // Feedbacks that need manual review
        let reviewedReviews = []; // Feedbacks that have been manually edited
        let currentFilteredReviews = []; // For Feedbacks List tab
        
        // Sorting state
        let currentSortColumn = null;
        let currentSortDirection = null;
        
        // Pagination state
        let currentPage = 1;
        let pageSize = 50;
        let totalPages = 1;

        // Keywords Manager Storage
        let customKeywords = {
            competitors: ['Golfshot', '18Birdies', 'SwingU', 'GolfNow', 'GolfLogix', 'Arccos', 'Shot Scope'],
            golfFeatures: ['GPS', 'yardage', 'scorecard', 'handicap', 'tee times', 'course guide', 'weather', 'shot tracking', 'putting', 'driving range'],
            featureRequests: ['dark mode', 'offline mode', 'Apple Watch', 'Android Wear', 'tournament mode', 'social features', 'leaderboard']
        };

        // Initialize data from localStorage on page load
        function initializeFromStorage() {
            console.log('Initializing from storage...');
            
            // Load all reviews
            const savedReviews = localStorage.getItem('appReviewScraper_reviews');
            if (savedReviews) {
                allReviews = JSON.parse(savedReviews);
                console.log(`Loaded ${allReviews.length} reviews from storage`);
            } else {
                console.log('No saved reviews found');
            }

            // Load data sources
            const savedSources = localStorage.getItem('appReviewScraper_sources');
            if (savedSources) {
                dataSources = JSON.parse(savedSources);
                console.log(`Loaded ${dataSources.length} data sources from storage`);
            } else {
                console.log('No saved data sources found');
            }

            // Load pending reviews
            const savedPending = localStorage.getItem('appReviewScraper_pending');
            if (savedPending) {
                pendingReviews = JSON.parse(savedPending);
                console.log(`Loaded ${pendingReviews.length} pending reviews from storage`);
            }

            // Load reviewed reviews
            const savedReviewed = localStorage.getItem('appReviewScraper_reviewed');
            if (savedReviewed) {
                reviewedReviews = JSON.parse(savedReviewed);
                console.log(`Loaded ${reviewedReviews.length} reviewed reviews from storage`);
            }

            // Load custom keywords
            const savedKeywords = localStorage.getItem('appReviewScraper_keywords');
            if (savedKeywords) {
                customKeywords = JSON.parse(savedKeywords);
                console.log('Loaded custom keywords from storage');
            }

            // Load current filtered reviews
            const savedFiltered = localStorage.getItem('appReviewScraper_filtered');
            if (savedFiltered) {
                currentFilteredReviews = JSON.parse(savedFiltered);
                console.log(`Loaded ${currentFilteredReviews.length} filtered reviews from storage`);
            }

            // Clean up any existing duplicates
            const originalCount = allReviews.length;
            allReviews = removeDuplicateReviews(allReviews);
            if (originalCount !== allReviews.length) {
                console.log(`Removed ${originalCount - allReviews.length} duplicate reviews on startup`);
                saveToStorage(); // Save the cleaned data
            }

            // Initialize current filtered reviews to show all reviews by default
            currentFilteredReviews = allReviews;
            
            // Update UI with loaded data
            console.log('Updating UI with loaded data...');
            updateDashboardMetrics(allReviews);
            updateReviewsTable();
            updatePagination();
            updateSourceFilter();
            updatePendingCount();
            updateSourceList();
            updateSourceCount();
            
            // Update keyword trends chart
            updateKeywordTrends();
            
            console.log('UI update completed');
        }

        // Save data to localStorage
        function saveToStorage() {
            localStorage.setItem('appReviewScraper_reviews', JSON.stringify(allReviews));
            localStorage.setItem('appReviewScraper_sources', JSON.stringify(dataSources));
            localStorage.setItem('appReviewScraper_pending', JSON.stringify(pendingReviews));
            localStorage.setItem('appReviewScraper_reviewed', JSON.stringify(reviewedReviews));
            localStorage.setItem('appReviewScraper_keywords', JSON.stringify(customKeywords));
            localStorage.setItem('appReviewScraper_filtered', JSON.stringify(currentFilteredReviews));
        }

        // Check if there's any data in localStorage
        function checkStorageData() {
            const keys = ['appReviewScraper_reviews', 'appReviewScraper_sources', 'appReviewScraper_pending', 'appReviewScraper_reviewed', 'appReviewScraper_keywords'];
            const data = {};
            
            keys.forEach(key => {
                const value = localStorage.getItem(key);
                data[key] = value ? JSON.parse(value) : null;
            });
            
            console.log('Storage data check:', data);
            return data;
        }

        // Clear all stored data
        function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This will remove all reviews, sources, and settings. This action cannot be undone.')) {
                allReviews = [];
                dataSources = [];
                pendingReviews = [];
                reviewedReviews = [];
                
                // Clear localStorage
                localStorage.removeItem('appReviewScraper_reviews');
                localStorage.removeItem('appReviewScraper_sources');
                localStorage.removeItem('appReviewScraper_pending');
                localStorage.removeItem('appReviewScraper_reviewed');
                
                // Update UI
                updateDashboardMetrics(allReviews);
                updateReviewsTable();
                updateSourceFilter();
                updatePendingCount();
                updateSourceList();
                updateSourceCount();
                
                alert('✅ All data has been cleared successfully!');
            }
        }

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - Starting initialization...');
            
            // Check what's in storage first
            checkStorageData();
            
            setupEventListeners();
            updateTime();
            initializeFromStorage(); // Load saved data
            setInterval(updateTime, 60000);
            updateSourceCount();
            
            // Add event listener for Keywords tab
            const keywordsTab = document.getElementById('keywords-tab');
            if (keywordsTab) {
                keywordsTab.addEventListener('shown.bs.tab', function() {
                    loadKeywordsManager();
                });
            }
            
            console.log('Initialization completed');
        });

        function setupEventListeners() {
            // Time period selector for Dashboard
            document.querySelectorAll('input[name="timePeriod"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateDashboardForPeriod(this.value);
                });
            });

            // Time period selector for List
            document.querySelectorAll('input[name="timePeriodList"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateListForPeriod(this.value);
                });
            });

            // Source type selector in modal
            document.getElementById('sourceType').addEventListener('change', function() {
                const apiConfig = document.getElementById('apiConfig');
                const fileConfig = document.getElementById('fileConfig');
                
                if (this.value === 'api') {
                    apiConfig.style.display = 'block';
                    fileConfig.style.display = 'none';
                } else if (['csv', 'excel', 'json'].includes(this.value)) {
                    apiConfig.style.display = 'none';
                    fileConfig.style.display = 'block';
                } else {
                    apiConfig.style.display = 'none';
                    fileConfig.style.display = 'none';
                }
            });

            // File upload handler
            document.getElementById('fileUpload').addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const fileName = file.name;
                    document.getElementById('sourceName').value = fileName.replace(/\.[^/.]+$/, "");
                }
            });

            // Auto-applying filters
            document.getElementById('sourceFilter').addEventListener('change', applyFilters);
            document.getElementById('userTypeFilter').addEventListener('change', applyFilters);
            document.getElementById('ratingFilter').addEventListener('change', applyFilters);
            document.getElementById('keywordSearch').addEventListener('input', applyFilters);
            document.getElementById('startDate').addEventListener('change', applyFilters);
            document.getElementById('endDate').addEventListener('change', applyFilters);
        }

        function updateDashboardForPeriod(days) {
            console.log(`Updating dashboard for last ${days} days`);
            console.log(`Total reviews available: ${allReviews.length}`);
            
            if (allReviews.length === 0) {
                console.log('No reviews available');
                return;
            }

            let filteredReviews;
            
            if (days === 0) {
                // All time - no filtering
                filteredReviews = allReviews;
                console.log(`All time selected - showing all ${filteredReviews.length} reviews`);
            } else {
                // Filter reviews by date
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);
                console.log(`Filtering from date: ${cutoffDate.toISOString()}`);
                
                filteredReviews = allReviews.filter(review => {
                    const reviewDate = new Date(review.date);
                    return reviewDate >= cutoffDate;
                });
                console.log(`Filtered to ${filteredReviews.length} reviews`);
            }

            console.log(`Updating dashboard with ${filteredReviews.length} reviews`);
            updateDashboardMetrics(filteredReviews);
            
            // Update keyword trends when global date selector changes
            updateKeywordTrends();
        }

        function updateListForPeriod(days) {
            console.log(`Updating list for last ${days} days`);
            
            if (allReviews.length === 0) {
                return;
            }

            let filteredReviews;
            
            if (days === 0) {
                // All time - no filtering
                filteredReviews = allReviews;
            } else {
                // Filter reviews by date
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);
                
                filteredReviews = allReviews.filter(review => {
                    const reviewDate = new Date(review.date);
                    return reviewDate >= cutoffDate;
                });
            }

            // Store filtered reviews globally
            currentFilteredReviews = filteredReviews;
            console.log(`Feedbacks List: Filtered to ${filteredReviews.length} feedbacks for ${days} days`);
            
            // Update the table with filtered data
            updateFilteredTable(filteredReviews);
            
            // Update results count
            document.getElementById('resultsCount').textContent = filteredReviews.length;
        }

        function updateDashboardMetrics(reviews) {
            if (reviews.length === 0) {
                document.getElementById('total-avg-rating').textContent = '0.0';
                document.getElementById('playstore-avg-rating').textContent = '0.0';
                document.getElementById('appstore-avg-rating').textContent = '0.0';
                // Clear comparison and trend charts
                document.getElementById('total-rating-change').textContent = 'No data';
                document.getElementById('playstore-rating-change').textContent = 'No data';
                document.getElementById('appstore-rating-change').textContent = 'No data';
                document.getElementById('total-rating-trend').innerHTML = '';
                document.getElementById('playstore-rating-trend').innerHTML = '';
                document.getElementById('appstore-rating-trend').innerHTML = '';
                return;
            }

            // Always calculate 3-month averages regardless of current time period
            updateThreeMonthRatingMetrics(reviews);

            // Update advanced analytics
            updateAdvancedAnalytics(reviews);
            
            // Update time period selector labels with feedback counts
            updateTimePeriodLabelsWithCounts(reviews);
        }

        // Calculate 3-month rating averages with comparison to previous 3 months
        function updateThreeMonthRatingMetrics(reviews) {
            console.log('Calculating 3-month rating metrics...');
            
            // Define 3-month periods
            const now = new Date();
            const threeMonthsAgo = new Date();
            threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
            
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            
            // Filter reviews for current 3 months
            const currentPeriodReviews = reviews.filter(review => {
                const reviewDate = new Date(review.date);
                return reviewDate >= threeMonthsAgo;
            });
            
            // Filter reviews for previous 3 months
            const previousPeriodReviews = reviews.filter(review => {
                const reviewDate = new Date(review.date);
                return reviewDate >= sixMonthsAgo && reviewDate < threeMonthsAgo;
            });
            
            console.log(`Current 3 months: ${currentPeriodReviews.length} reviews`);
            console.log(`Previous 3 months: ${previousPeriodReviews.length} reviews`);
            
            // Calculate current period averages
            const currentTotalAvg = calculateAverageRating(currentPeriodReviews);
            const currentPlayStoreAvg = calculateAverageRating(currentPeriodReviews.filter(r => r.source === 'google_play'));
            const currentAppStoreAvg = calculateAverageRating(currentPeriodReviews.filter(r => r.source === 'app_store'));
            
            // Calculate previous period averages
            const previousTotalAvg = calculateAverageRating(previousPeriodReviews);
            const previousPlayStoreAvg = calculateAverageRating(previousPeriodReviews.filter(r => r.source === 'google_play'));
            const previousAppStoreAvg = calculateAverageRating(previousPeriodReviews.filter(r => r.source === 'app_store'));
            
            // Update rating displays
            document.getElementById('total-avg-rating').textContent = currentTotalAvg.toFixed(1);
            document.getElementById('playstore-avg-rating').textContent = currentPlayStoreAvg.toFixed(1);
            document.getElementById('appstore-avg-rating').textContent = currentAppStoreAvg.toFixed(1);
            
            // Update comparison text
            updateRatingComparison('total-rating-change', currentTotalAvg, previousTotalAvg);
            updateRatingComparison('playstore-rating-change', currentPlayStoreAvg, previousPlayStoreAvg);
            updateRatingComparison('appstore-rating-change', currentAppStoreAvg, previousAppStoreAvg);
            
            // Update trend charts (monthly data for 6 months)
            updateRatingTrendPreview('total-rating-trend', reviews, 'total');
            updateRatingTrendPreview('playstore-rating-trend', reviews, 'google_play');
            updateRatingTrendPreview('appstore-rating-trend', reviews, 'app_store');
        }
        
        // Update rating comparison text
        function updateRatingComparison(elementId, current, previous) {
            const element = document.getElementById(elementId);
            
            if (current === 0 && previous === 0) {
                element.textContent = 'No data';
                element.style.color = 'var(--medium-gray)';
                return;
            }
            
            if (previous === 0) {
                element.textContent = 'New';
                element.style.color = 'var(--success)';
                return;
            }
            
            const difference = current - previous;
            const sign = difference >= 0 ? '+' : '';
            
            element.textContent = `${sign}${difference.toFixed(1)}`;
            
            if (difference > 0.1) {
                element.style.color = 'var(--success)'; // Green for improvement
            } else if (difference < -0.1) {
                element.style.color = 'var(--danger)'; // Red for decline
            } else {
                element.style.color = 'var(--medium-gray)'; // Gray for no significant change
            }
        }

        // Update rating trend preview (monthly data for 6 months)
        function updateRatingTrendPreview(containerId, reviews, sourceType) {
            console.log(`updateRatingTrendPreview: ${containerId}, source: ${sourceType}`);
            const container = document.getElementById(containerId);
            
            // Filter reviews by source type
            let filteredReviews = reviews;
            if (sourceType !== 'total') {
                filteredReviews = reviews.filter(r => r.source === sourceType);
            }
            
            if (filteredReviews.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            // Generate monthly data for last 6 months
            const monthlyData = generateMonthlyRatingData(filteredReviews, 6);
            
            if (monthlyData.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            // Create mini chart
            const trace = {
                x: monthlyData.map(d => d.month),
                y: monthlyData.map(d => d.avgRating),
                type: 'scatter',
                mode: 'lines+markers',
                line: {
                    color: '#007bff',
                    width: 2
                },
                marker: {
                    size: 3,
                    color: '#007bff'
                },
                showlegend: false,
                hoverinfo: 'skip'
            };
            
            const layout = {
                margin: { t: 0, b: 0, l: 0, r: 0 },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                xaxis: {
                    visible: false
                },
                yaxis: {
                    visible: false
                },
                autosize: true
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            Plotly.newPlot(container, [trace], layout, config);
        }
        
        // Generate monthly rating data for the last N months
        function generateMonthlyRatingData(reviews, months) {
            const monthlyRatings = {};
            
            // Initialize last N months
            for (let i = months - 1; i >= 0; i--) {
                const date = new Date();
                date.setMonth(date.getMonth() - i);
                const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                monthlyRatings[monthKey] = { total: 0, count: 0, avgRating: 0 };
            }
            
            // Process reviews
            reviews.forEach(review => {
                const reviewDate = new Date(review.date);
                const monthKey = `${reviewDate.getFullYear()}-${(reviewDate.getMonth() + 1).toString().padStart(2, '0')}`;
                
                if (monthlyRatings[monthKey]) {
                    const rating = parseFloat(review.rating);
                    if (!isNaN(rating) && rating > 0 && rating <= 5) {
                        monthlyRatings[monthKey].total += rating;
                        monthlyRatings[monthKey].count += 1;
                    }
                }
            });
            
            // Calculate averages and format for chart
            const data = Object.entries(monthlyRatings)
                .map(([month, data]) => ({
                    month: month.substring(5), // Just the month part (MM)
                    avgRating: data.count > 0 ? Math.round((data.total / data.count) * 10) / 10 : 0
                }))
                .filter(d => d.avgRating > 0); // Only include months with data
            
            return data;
        }

        // Calculate average rating for a set of reviews
        function calculateAverageRating(reviews) {
            const reviewsWithRating = reviews.filter(r => {
                const rating = parseFloat(r.rating);
                return !isNaN(rating) && rating > 0 && rating <= 5;
            });
            
            if (reviewsWithRating.length === 0) return 0;
            
            const avg = reviewsWithRating.reduce((sum, r) => sum + parseFloat(r.rating), 0) / reviewsWithRating.length;
            return Math.round(avg * 10) / 10;
        }

        // Update time period selector labels with feedback counts
        function updateTimePeriodLabelsWithCounts(reviews) {
            const timePeriods = [
                { id: 'last7days', listId: 'last7daysList', label: 'Last 7 days', days: 7 },
                { id: 'lastMonth', listId: 'lastMonthList', label: 'Last month', days: 30 },
                { id: 'last3Months', listId: 'last3MonthsList', label: '3 months', days: 90 },
                { id: 'last6Months', listId: 'last6MonthsList', label: '6 months', days: 180 },
                { id: 'lastYear', listId: 'lastYearList', label: '1 year', days: 365 },
                { id: 'allTime', listId: 'allTimeList', label: 'All time', days: 0 }
            ];

            timePeriods.forEach(period => {
                let count = 0;
                
                if (period.days === 0) {
                    count = reviews.length;
                } else {
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - period.days);
                    count = reviews.filter(review => {
                        const reviewDate = new Date(review.date);
                        return reviewDate >= cutoffDate;
                    }).length;
                }

                // Update Dashboard time period label
                const dashboardLabel = document.querySelector(`label[for="${period.id}"]`);
                if (dashboardLabel) {
                    dashboardLabel.textContent = `${period.label} (${count})`;
                }

                // Update Feedbacks List time period label
                const listLabel = document.querySelector(`label[for="${period.listId}"]`);
                if (listLabel) {
                    listLabel.textContent = `${period.label} (${count})`;
                }
            });
        }

        function updateAdvancedAnalytics(reviews) {
            try {
                // Update keywords list for trends
                updateKeywordsList();
                
                // Update lists
                updatePainPointsList(reviews);
                updateAdvantagesList(reviews);
                updateRequestedFeaturesList(reviews);
                
                // Update charts
                updatePainPointsChart(reviews);
                updateRequestedFeaturesChart(reviews);
            } catch (error) {
                console.error('Error updating advanced analytics:', error);
            }
        }

        function updateKeywordsCloud(reviews) {
            // Get all managed keywords from customKeywords
            const managedKeywords = [
                ...customKeywords.competitors,
                ...customKeywords.golfFeatures,
                ...customKeywords.featureRequests
            ];
            
            const keywords = extractAllKeywords(reviews);
            const container = document.getElementById('keywordsCloud');
            
            if (Object.keys(keywords).length === 0) {
                container.innerHTML = '<p class="text-muted">No keywords available</p>';
                return;
            }
            
            // Only show managed keywords that appear in reviews
            const availableManagedKeywords = managedKeywords.filter(keyword => 
                keywords.hasOwnProperty(keyword.toLowerCase())
            );
            
            if (availableManagedKeywords.length === 0) {
                container.innerHTML = '<p class="text-muted">No managed keywords found in reviews</p>';
                return;
            }
            
            // Sort by frequency and take top 20
            const sortedKeywords = availableManagedKeywords
                .map(keyword => ({ keyword, count: keywords[keyword.toLowerCase()] || 0 }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 20);
            
            const keywordCloud = sortedKeywords.map(({ keyword, count }, index) => {
                let sizeClass = 'fs-7';
                let badgeClass = 'bg-light text-dark';
                
                // Different sizes for visual hierarchy
                if (index < 3) {
                    sizeClass = 'fs-5';
                    badgeClass = 'bg-primary text-white';
                } else if (index < 6) {
                    sizeClass = 'fs-6';
                    badgeClass = 'bg-info text-white';
                } else if (index < 10) {
                    sizeClass = 'fs-6';
                    badgeClass = 'bg-light text-dark';
                }
                
                return `<span class="badge ${badgeClass} me-1 mb-1 ${sizeClass}" title="${count} mentions">${keyword}</span>`;
            }).join('');
            
            container.innerHTML = keywordCloud;
        }

        function updatePainPointsList(reviews) {
            const container = document.getElementById('painPointsList');
            
            if (reviews.length === 0) {
                container.innerHTML = '<p class="text-muted">No pain points identified</p>';
                return;
            }

            const painPoints = analyzePainPoints(reviews);
            
            // Combine all pain points and sort by frequency
            const allPainPoints = [];
            Object.entries(painPoints.critical).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Critical'}));
            Object.entries(painPoints.features).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Feature'}));
            Object.entries(painPoints.performance).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Performance'}));
            Object.entries(painPoints.ux).forEach(([text, count]) => allPainPoints.push({text, count, category: 'UX'}));
            
            // Sort by frequency and take top 10
            const sortedPainPoints = allPainPoints
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);
            
            if (sortedPainPoints.length === 0) {
                container.innerHTML = '<p class="text-muted">No pain points identified</p>';
                return;
            }
            
            const list = sortedPainPoints.map((item, index) => `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="me-2">${index + 1}.</span>
                    <span class="flex-grow-1">${item.text}</span>
                    <span class="badge bg-danger">${item.count}</span>
                </div>
            `).join('');
            
            container.innerHTML = list;
        }

        function updateAdvantagesList(reviews) {
            const container = document.getElementById('advantagesList');
            
            if (reviews.length === 0) {
                container.innerHTML = '<p class="text-muted">No advantages identified</p>';
                return;
            }

            const advantages = analyzeAdvantages(reviews);
            
            // Combine all advantages and sort by frequency
            const allAdvantages = [];
            Object.entries(advantages.features).forEach(([text, count]) => allAdvantages.push({text, count, category: 'Feature'}));
            Object.entries(advantages.performance).forEach(([text, count]) => allAdvantages.push({text, count, category: 'Performance'}));
            Object.entries(advantages.ux).forEach(([text, count]) => allAdvantages.push({text, count, category: 'UX'}));
            Object.entries(advantages.competitive).forEach(([text, count]) => allAdvantages.push({text, count, category: 'Competitive'}));
            
            // Sort by frequency and take top 10
            const sortedAdvantages = allAdvantages
                .sort((a, b) => b.count - a.count)
                .slice(0, 10);
            
            if (sortedAdvantages.length === 0) {
                container.innerHTML = '<p class="text-muted">No advantages identified</p>';
                return;
            }
            
            const list = sortedAdvantages.map((item, index) => `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="me-2">${index + 1}.</span>
                    <span class="flex-grow-1">${item.text}</span>
                    <span class="badge bg-success">${item.count}</span>
                </div>
            `).join('');
            
            container.innerHTML = list;
        }

        function updateRequestedFeaturesList(reviews) {
            const container = document.getElementById('requestedFeaturesList');
            
            if (reviews.length === 0) {
                container.innerHTML = '<p class="text-muted">No feature requests identified</p>';
                return;
            }

            // Use the existing feature requests from keywords manager
            const featureRequests = customKeywords.featureRequests || [];
            
            if (featureRequests.length === 0) {
                container.innerHTML = '<p class="text-muted">No feature requests configured</p>';
                return;
            }

            // Count mentions of each feature request in reviews
            const requestCounts = {};
            featureRequests.forEach(request => {
                requestCounts[request] = 0;
            });

            reviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                featureRequests.forEach(request => {
                    if (content.includes(request.toLowerCase())) {
                        requestCounts[request] = (requestCounts[request] || 0) + 1;
                    }
                });
            });

            // Sort by frequency and take top 10
            const sortedRequests = Object.entries(requestCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10)
                .filter(([,count]) => count > 0); // Only show requests that were mentioned
            
            if (sortedRequests.length === 0) {
                container.innerHTML = '<p class="text-muted">No feature requests mentioned in reviews</p>';
                return;
            }
            
            const list = sortedRequests.map(([request, count], index) => `
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="me-2">${index + 1}.</span>
                    <span class="flex-grow-1">${request}</span>
                    <span class="badge bg-warning text-dark">${count}</span>
                </div>
            `).join('');
            
            container.innerHTML = list;
        }

        function updatePainPointsChart(reviews) {
            const container = document.getElementById('painPointsChart');
            
            if (reviews.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                            <p>No pain points data available</p>
                        </div>
                    </div>
                `;
                return;
            }

            const painPoints = analyzePainPoints(reviews);
            
            // Combine all pain points and sort by frequency
            const allPainPoints = [];
            Object.entries(painPoints.critical).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Critical'}));
            Object.entries(painPoints.features).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Feature'}));
            Object.entries(painPoints.performance).forEach(([text, count]) => allPainPoints.push({text, count, category: 'Performance'}));
            Object.entries(painPoints.ux).forEach(([text, count]) => allPainPoints.push({text, count, category: 'UX'}));
            
            // Sort by frequency and take top 8 for chart
            const sortedPainPoints = allPainPoints
                .sort((a, b) => b.count - a.count)
                .slice(0, 8);
            
            if (sortedPainPoints.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                            <p>No pain points data available</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Create pie chart using Plotly
            const data = [{
                values: sortedPainPoints.map(p => p.count),
                labels: sortedPainPoints.map(p => p.text),
                type: 'pie',
                textinfo: 'label+percent',
                textposition: 'outside',
                marker: {
                    colors: ['#ff6b6b', '#ff8e53', '#ff6b9d', '#c44569', '#f8b500', '#ff9ff3', '#54a0ff', '#5f27cd'],
                    line: {
                        color: '#ffffff',
                        width: 2
                    }
                },
                hovertemplate: '<b>%{label}</b><br>Mentions: %{value}<br>Percentage: %{percent}<extra></extra>',
                hoverlabel: {
                    bgcolor: '#ffffff',
                    bordercolor: '#333333',
                    font: {
                        color: '#333333',
                        size: 14
                    }
                }
            }];
            
            const layout = {
                margin: { t: 0, b: 0, l: 0, r: 0 },
                showlegend: false,
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'transparent',
                font: {
                    color: '#24292f'
                },
                hovermode: 'closest'
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            Plotly.newPlot(container, data, layout, config);
        }

        function updateRequestedFeaturesChart(reviews) {
            const container = document.getElementById('requestedFeaturesChart');
            
            if (reviews.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                            <p>No feature requests data available</p>
                        </div>
                    </div>
                `;
                return;
            }

            // Use the existing feature requests from keywords manager
            const featureRequests = customKeywords.featureRequests || [];
            
            if (featureRequests.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                            <p>No feature requests configured</p>
                        </div>
                    </div>
                `;
                return;
            }

            // Count mentions of each feature request in reviews
            const requestCounts = {};
            featureRequests.forEach(request => {
                requestCounts[request] = 0;
            });

            reviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                featureRequests.forEach(request => {
                    if (content.includes(request.toLowerCase())) {
                        requestCounts[request] = (requestCounts[request] || 0) + 1;
                    }
                });
            });

            // Sort by frequency and take top 8 for chart, filter out 0 mentions
            const sortedRequests = Object.entries(requestCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 8)
                .filter(([,count]) => count > 0); // Only show requests that were mentioned
            
            if (sortedRequests.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-pie fa-3x mb-3"></i>
                            <p>No feature requests mentioned in reviews</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Create pie chart using Plotly
            const data = [{
                values: sortedRequests.map(([request, count]) => count),
                labels: sortedRequests.map(([request, count]) => request),
                type: 'pie',
                textinfo: 'label+percent',
                textposition: 'outside',
                marker: {
                    colors: ['#ffd93d', '#6bcf7f', '#4d9de0', '#e15554', '#e1bc29', '#3bb273', '#7768ae', '#f7b2ad'],
                    line: {
                        color: '#ffffff',
                        width: 2
                    }
                },
                hovertemplate: '<b>%{label}</b><br>Mentions: %{value}<br>Percentage: %{percent}<extra></extra>',
                hoverlabel: {
                    bgcolor: '#ffffff',
                    bordercolor: '#333333',
                    font: {
                        color: '#333333',
                        size: 14
                    }
                }
            }];
            
            const layout = {
                margin: { t: 0, b: 0, l: 0, r: 0 },
                showlegend: false,
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'transparent',
                font: {
                    color: '#24292f'
                },
                hovermode: 'closest'
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            Plotly.newPlot(container, data, layout, config);
        }

        function updateKeywordSelector(reviews) {
            // Get all managed keywords from customKeywords
            const managedKeywords = [
                ...customKeywords.competitors,
                ...customKeywords.golfFeatures,
                ...customKeywords.featureRequests
            ];
            
            const selector = document.getElementById('keywordSelector');
            
            // Clear existing options except the first one
            selector.innerHTML = '<option value="">Select keywords...</option>';
            
            // Only show managed keywords that appear in reviews
            const keywords = extractAllKeywords(reviews);
            const availableManagedKeywords = managedKeywords.filter(keyword => 
                keywords.hasOwnProperty(keyword.toLowerCase())
            );
            
            // Sort by frequency in reviews
            const sortedKeywords = availableManagedKeywords
                .map(keyword => ({ keyword, count: keywords[keyword.toLowerCase()] || 0 }))
                .sort((a, b) => b.count - a.count);
            
            sortedKeywords.forEach(({ keyword, count }) => {
                const option = document.createElement('option');
                option.value = keyword;
                option.textContent = `${keyword} (${count})`;
                selector.appendChild(option);
            });
        }

        // Global variable to store selected keywords for trends
        let selectedKeywordsForTrends = [];
        let currentKeywordsPage = 1;
        const keywordsPerPage = 10;

        // Update keywords list with checkboxes and pagination
        function updateKeywordsList() {
            try {
                const container = document.getElementById('keywordsList');
                if (!container) {
                    console.log('Keywords list container not found, skipping update');
                    return;
                }
                
                const searchInput = document.getElementById('keywordSearchInput');
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                
                // Get all managed keywords from customKeywords
                const managedKeywords = [
                    ...customKeywords.competitors,
                    ...customKeywords.golfFeatures,
                    ...customKeywords.featureRequests
                ];
                
                if (managedKeywords.length === 0) {
                    container.innerHTML = '<p class="text-muted text-center">No keywords managed yet. Add keywords in Keywords tab.</p>';
                    updateKeywordsPagination([]);
                    return;
                }

                // Count keyword frequency in reviews
                const keywordCounts = {};
                managedKeywords.forEach(keyword => {
                    keywordCounts[keyword] = 0;
                });

                allReviews.forEach(review => {
                    const content = review.content?.toLowerCase() || '';
                    managedKeywords.forEach(keyword => {
                        if (content.includes(keyword.toLowerCase())) {
                            keywordCounts[keyword] = (keywordCounts[keyword] || 0) + 1;
                        }
                    });
                });

                // Filter keywords based on search term
                const filteredKeywords = managedKeywords.filter(keyword => 
                    keyword.toLowerCase().includes(searchTerm)
                );

                // Sort by frequency
                const sortedKeywords = filteredKeywords
                    .map(keyword => ({ keyword, count: keywordCounts[keyword] }))
                    .sort((a, b) => b.count - a.count);

                // Update pagination
                updateKeywordsPagination(sortedKeywords);

                // Get keywords for current page
                const startIndex = (currentKeywordsPage - 1) * keywordsPerPage;
                const endIndex = startIndex + keywordsPerPage;
                const pageKeywords = sortedKeywords.slice(startIndex, endIndex);

                if (pageKeywords.length === 0) {
                    container.innerHTML = '<p class="text-muted text-center">No keywords match your search.</p>';
                    return;
                }

                // Auto-select first 5 keywords on first page if none selected
                if (currentKeywordsPage === 1 && selectedKeywordsForTrends.length === 0 && pageKeywords.length > 0) {
                    selectedKeywordsForTrends = pageKeywords.slice(0, 5).map(item => item.keyword);
                }

                // Create checkboxes
                const checkboxesHTML = pageKeywords.map(({ keyword, count }) => {
                    const isSelected = selectedKeywordsForTrends.includes(keyword);
                    const isDisabled = !isSelected && selectedKeywordsForTrends.length >= 5;
                    
                    return `
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" 
                                   id="keyword-${keyword}" 
                                   value="${keyword}" 
                                   ${isSelected ? 'checked' : ''} 
                                   ${isDisabled ? 'disabled' : ''}
                                   onchange="toggleKeywordSelection('${keyword}')">
                            <label class="form-check-label d-flex justify-content-between align-items-center" for="keyword-${keyword}">
                                <span>${keyword}</span>
                                <span class="badge bg-secondary">${count}</span>
                            </label>
                        </div>
                    `;
                }).join('');

                container.innerHTML = checkboxesHTML;
                updateSelectedKeywordsCount();
            } catch (error) {
                console.error('Error updating keywords list:', error);
            }
        }

        // Update keywords pagination
        function updateKeywordsPagination(sortedKeywords) {
            try {
                const paginationContainer = document.getElementById('keywordsPagination');
                if (!paginationContainer) {
                    console.log('Keywords pagination container not found, skipping update');
                    return;
                }
                
                const totalPages = Math.ceil(sortedKeywords.length / keywordsPerPage);
                
                if (totalPages <= 1) {
                    paginationContainer.innerHTML = '';
                    return;
                }

                let paginationHTML = '';
                
                // Previous button
                if (currentKeywordsPage > 1) {
                    paginationHTML += `<button type="button" class="btn btn-outline-secondary" onclick="changeKeywordsPage(${currentKeywordsPage - 1})">‹</button>`;
                }
                
                // Page numbers
                const startPage = Math.max(1, currentKeywordsPage - 2);
                const endPage = Math.min(totalPages, currentKeywordsPage + 2);
                
                for (let i = startPage; i <= endPage; i++) {
                    const isActive = i === currentKeywordsPage;
                    paginationHTML += `<button type="button" class="btn ${isActive ? 'btn-primary' : 'btn-outline-secondary'}" onclick="changeKeywordsPage(${i})">${i}</button>`;
                }
                
                // Next button
                if (currentKeywordsPage < totalPages) {
                    paginationHTML += `<button type="button" class="btn btn-outline-secondary" onclick="changeKeywordsPage(${currentKeywordsPage + 1})">›</button>`;
                }
                
                paginationContainer.innerHTML = paginationHTML;
            } catch (error) {
                console.error('Error updating keywords pagination:', error);
            }
        }

        // Change keywords page
        function changeKeywordsPage(page) {
            currentKeywordsPage = page;
            updateKeywordsList();
        }

        // Toggle keyword selection for trends
        function toggleKeywordSelection(keyword) {
            const checkbox = document.getElementById(`keyword-${keyword}`);
            
            if (checkbox.checked) {
                if (selectedKeywordsForTrends.length < 5) {
                    selectedKeywordsForTrends.push(keyword);
                } else {
                    checkbox.checked = false;
                    alert('Maximum 5 keywords can be selected for trends analysis.');
                    return;
                }
            } else {
                selectedKeywordsForTrends = selectedKeywordsForTrends.filter(k => k !== keyword);
            }
            
            updateSelectedKeywordsCount();
            updateKeywordsList(); // Refresh to update disabled state
            updateKeywordTrends(); // Auto-update chart
        }

        // Update selected keywords count badge
        function updateSelectedKeywordsCount() {
            const countElement = document.getElementById('selectedKeywordsCount');
            if (countElement) {
                countElement.textContent = selectedKeywordsForTrends.length;
                countElement.className = selectedKeywordsForTrends.length > 0 ? 
                    'badge bg-primary ms-2' : 'badge bg-secondary ms-2';
            }
        }

        // Filter keywords based on search input
        function filterKeywords() {
            currentKeywordsPage = 1; // Reset to first page when searching
            updateKeywordsList();
        }

        // Get current global time period
        function getCurrentTimePeriod() {
            const selectedPeriod = document.querySelector('input[name="timePeriod"]:checked');
            const value = selectedPeriod ? selectedPeriod.value : '0'; // Default to "All time"
            console.log(`Current time period: ${value}`);
            return value;
        }

        // Get current step size based on time period
        function getCurrentStepSize() {
            const timePeriod = getCurrentTimePeriod();
            const stepSizeSelector = document.getElementById('stepSizeSelector');
            
            // Auto-set step size based on time period
            if (timePeriod === '7' || timePeriod === '30') {
                stepSizeSelector.value = 'day';
            } else if (timePeriod === '90' || timePeriod === '180') {
                stepSizeSelector.value = 'week';
            } else if (timePeriod === '365' || timePeriod === 'all') {
                stepSizeSelector.value = 'week'; // Default to week, user can change
            }
            
            return stepSizeSelector ? stepSizeSelector.value : 'week';
        }

        function updateKeywordTrends() {
            const container = document.getElementById('keywordTrendsChart');
            const timePeriod = getCurrentTimePeriod();
            const stepSize = getCurrentStepSize();
            
            if (selectedKeywordsForTrends.length === 0) {
                container.innerHTML = `
                    <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                        <div class="text-center">
                            <i class="fas fa-chart-line fa-3x mb-3"></i>
                            <p>Select keywords above to see trends</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get filtered reviews based on global time period
            let filteredReviews = allReviews;
            console.log(`Keyword trends - Total reviews: ${allReviews.length}, Time period: ${timePeriod}`);
            
            if (timePeriod !== 'all' && timePeriod !== '0') {
                const days = parseInt(timePeriod);
                const cutoffDate = new Date();
                cutoffDate.setDate(cutoffDate.getDate() - days);
                console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
                
                filteredReviews = allReviews.filter(review => {
                    const reviewDate = new Date(review.date);
                    const isValid = reviewDate >= cutoffDate;
                    if (!isValid) {
                        console.log(`Review filtered out - Date: ${review.date}, Parsed: ${reviewDate.toISOString()}`);
                    }
                    return isValid;
                });
                console.log(`Filtered reviews: ${filteredReviews.length}`);
            }
            
            if (filteredReviews.length === 0) {
                console.log('No reviews found for selected time period, showing all reviews instead');
                filteredReviews = allReviews; // Fallback to show all reviews
                
                if (filteredReviews.length === 0) {
                    container.innerHTML = `
                        <div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);">
                            <div class="text-center">
                                <i class="fas fa-chart-line fa-3x mb-3"></i>
                                <p>No reviews available</p>
                            </div>
                        </div>
                    `;
                    return;
                }
            }
            
            // Group reviews by step size
            const stepData = {};
            const colors = ['#ff6b6b', '#ff8e53', '#ff6b9d', '#c44569', '#f8b500'];
            
            selectedKeywordsForTrends.forEach((keyword, index) => {
                stepData[keyword] = {};
                
                filteredReviews.forEach(review => {
                    const reviewDate = new Date(review.date);
                    const stepKey = getStepKey(reviewDate, stepSize);
                    
                    if (!stepData[keyword][stepKey]) {
                        stepData[keyword][stepKey] = 0;
                    }
                    
                    if (review.content && review.content.toLowerCase().includes(keyword.toLowerCase())) {
                        stepData[keyword][stepKey]++;
                    }
                });
            });
            
            // Prepare data for Plotly
            const traces = selectedKeywordsForTrends.map((keyword, index) => {
                const steps = Object.keys(stepData[keyword]).sort();
                const counts = steps.map(step => stepData[keyword][step]);
                
                return {
                    x: steps,
                    y: counts,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: keyword,
                    line: {
                        color: colors[index % colors.length],
                        width: 3
                    },
                    marker: {
                        size: 6,
                        color: colors[index % colors.length]
                    }
                };
            });
            
            const layout = {
                title: {
                    text: `Keyword Trends - ${getTimePeriodLabel(timePeriod)} (${stepSize === 'day' ? 'Daily' : stepSize === 'week' ? 'Weekly' : 'Monthly'})`,
                    font: { size: 16, color: '#24292f' }
                },
                xaxis: {
                    title: stepSize === 'day' ? 'Day' : stepSize === 'week' ? 'Week' : 'Month',
                    gridcolor: '#e1e4e8',
                    color: '#24292f'
                },
                yaxis: {
                    title: 'Mentions',
                    gridcolor: '#e1e4e8',
                    color: '#24292f'
                },
                plot_bgcolor: 'transparent',
                paper_bgcolor: 'transparent',
                font: {
                    color: '#24292f'
                },
                legend: {
                    orientation: 'h',
                    y: -0.2,
                    x: 0.5,
                    xanchor: 'center'
                },
                margin: { t: 60, b: 80, l: 60, r: 40 }
            };
            
            Plotly.newPlot(container, traces, layout, {responsive: true});
        }
        
        // Helper function to get time period label
        function getTimePeriodLabel(period) {
            const labels = {
                '7': 'Last 7 days',
                '30': 'Last 30 days',
                '90': 'Last 3 months',
                '180': 'Last 6 months',
                '365': 'Last year',
                '0': 'All time',
                'all': 'All time'
            };
            return labels[period] || 'All time';
        }

        // Helper function to get step key based on step size
        function getStepKey(date, stepSize) {
            if (stepSize === 'day') {
                return date.toISOString().split('T')[0]; // YYYY-MM-DD
            } else if (stepSize === 'week') {
                const year = date.getFullYear();
                const week = getWeekNumber(date);
                return `${year}-W${week.toString().padStart(2, '0')}`;
            } else if (stepSize === 'month') {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                return `${year}-${month.toString().padStart(2, '0')}`;
            }
            return date.toISOString().split('T')[0];
        }

        // Helper function to get week number
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function updateCharts(reviews) {
            if (reviews.length === 0) {
                // Clear charts
                document.getElementById('sentiment-chart').innerHTML = '<div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);"><div class="text-center"><i class="fas fa-chart-pie fa-3x mb-3"></i><p>No data available</p></div></div>';
                document.getElementById('source-chart').innerHTML = '<div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);"><div class="text-center"><i class="fas fa-mobile-alt fa-3x mb-3"></i><p>No data available</p></div></div>';
                document.getElementById('rating-chart').innerHTML = '<div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);"><div class="text-center"><i class="fas fa-star fa-3x mb-3"></i><p>No data available</p></div></div>';
                document.getElementById('trends-chart').innerHTML = '<div class="d-flex align-items-center justify-content-center h-100" style="color: var(--medium-gray);"><div class="text-center"><i class="fas fa-chart-line fa-3x mb-3"></i><p>No data available</p></div></div>';
                return;
            }

            // Sentiment chart
            const sentimentCounts = {};
            reviews.forEach(review => {
                const sentiment = review.sentiment || 'unknown';
                sentimentCounts[sentiment] = (sentimentCounts[sentiment] || 0) + 1;
            });

            const sentimentData = {
                values: Object.values(sentimentCounts),
                labels: Object.keys(sentimentCounts),
                type: 'pie',
                marker: { 
                    colors: ['#0969da', '#656d76', '#8b949e'],
                    line: { color: '#ffffff', width: 1 }
                }
            };

            Plotly.newPlot('sentiment-chart', [sentimentData], {
                margin: { t: 20, b: 20, l: 20, r: 20 },
                showlegend: true,
                legend: { orientation: 'h', y: -0.1 },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#24292f', size: 12 }
            });

            // Source chart
            const sourceCounts = {};
            reviews.forEach(review => {
                const source = review.source || 'unknown';
                sourceCounts[source] = (sourceCounts[source] || 0) + 1;
            });

            const sourceData = {
                x: Object.keys(sourceCounts),
                y: Object.values(sourceCounts),
                type: 'bar',
                marker: { 
                    color: '#0969da',
                    line: { color: '#ffffff', width: 1 }
                }
            };

            Plotly.newPlot('source-chart', [sourceData], {
                margin: { t: 20, b: 20, l: 20, r: 20 },
                xaxis: { title: 'Data Source' },
                yaxis: { title: 'Number of Reviews' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#24292f', size: 12 }
            });

            // Rating chart
            const ratingCounts = {};
            reviews.forEach(review => {
                if (review.rating && !isNaN(review.rating)) {
                    const rating = Math.round(review.rating);
                    ratingCounts[rating] = (ratingCounts[rating] || 0) + 1;
                }
            });

            if (Object.keys(ratingCounts).length > 0) {
                const ratingData = {
                    x: Object.keys(ratingCounts).map(r => r),
                    y: Object.values(ratingCounts),
                    type: 'bar',
                    marker: { 
                        color: '#0969da',
                        line: { color: '#ffffff', width: 1 }
                    }
                };

                Plotly.newPlot('rating-chart', [ratingData], {
                    margin: { t: 20, b: 20, l: 20, r: 20 },
                    xaxis: { title: 'Rating' },
                    yaxis: { title: 'Number of Reviews' },
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    font: { color: '#24292f', size: 12 }
                });
            }

            // Trends chart (simplified - by month)
            const monthlyCounts = {};
            reviews.forEach(review => {
                const date = new Date(review.date);
                const monthKey = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0');
                monthlyCounts[monthKey] = (monthlyCounts[monthKey] || 0) + 1;
            });

            const sortedMonths = Object.keys(monthlyCounts).sort();
            const trendsData = {
                x: sortedMonths,
                y: sortedMonths.map(month => monthlyCounts[month]),
                type: 'scatter',
                mode: 'lines+markers',
                line: { color: '#0969da', width: 2 },
                marker: { size: 6, color: '#0969da' }
            };

            Plotly.newPlot('trends-chart', [trendsData], {
                margin: { t: 20, b: 20, l: 20, r: 20 },
                xaxis: { title: 'Time Period' },
                yaxis: { title: 'Number of Reviews' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#24292f', size: 12 }
            });
        }

        function saveSource() {
            const form = document.getElementById('addSourceForm');
            const sourceType = document.getElementById('sourceType').value;
            const sourceName = document.getElementById('sourceName').value;
            const fileInput = document.getElementById('fileUpload');
            const description = document.getElementById('sourceDescription').value;

            if (!sourceName) {
                alert('Please enter a source name');
                return;
            }

            if (sourceType === 'csv' || sourceType === 'excel' || sourceType === 'json') {
                if (!fileInput.files[0]) {
                    alert('Please select a file to upload');
                    return;
                }

                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        let data;
                        if (sourceType === 'csv') {
                            data = parseCSV(e.target.result);
                        } else if (sourceType === 'json') {
                            data = JSON.parse(e.target.result);
                        } else {
                            alert('Excel files not yet supported. Please convert to CSV.');
                            return;
                        }

                        // Validate data structure
                        const validation = validateDataStructure(data);
                        if (!validation.valid) {
                            alert('No valid reviews found. Please ensure your file has the required columns: date, content');
                            return;
                        }

                        // Check for duplicates
                        const duplicateCheck = detectDuplicates(validation.validReviews, allReviews);
                        
                        if (duplicateCheck.duplicates.length > 0) {
                            const proceed = confirm(
                                `Found ${duplicateCheck.duplicates.length} duplicate reviews that already exist in the system.\n\n` +
                                `• ${duplicateCheck.unique.length} new unique reviews will be added\n` +
                                `• ${duplicateCheck.duplicates.length} duplicate reviews will be skipped\n\n` +
                                `Do you want to continue and add only the unique reviews?`
                            );
                            
                            if (!proceed) {
                                return;
                            }
                        }

                        // Add valid reviews to data sources
                        const newSource = {
                            id: Date.now(),
                            name: sourceName,
                            type: sourceType,
                            description: description,
                            data: duplicateCheck.unique,
                            createdAt: new Date().toISOString()
                        };

                        dataSources.push(newSource);
                        allReviews = allReviews.concat(duplicateCheck.unique);
                        currentFilteredReviews = allReviews; // Update filtered reviews to show all

                        // Save to localStorage
                        saveToStorage();

                        // Update UI
                        updateSourceCount();
                        updateSourceList();
                        updateDashboardMetrics(allReviews);
                        updateReviewsTable();
                        updateSourceFilter();

                        // Close modal
                        const modal = bootstrap.Modal.getInstance(document.getElementById('addSourceModal'));
                        modal.hide();

                        // Reset form
                        form.reset();
                        document.getElementById('apiConfig').style.display = 'none';
                        document.getElementById('fileConfig').style.display = 'block';

                        // Handle problematic reviews
                        console.log('Validation result:', validation);
                        if (validation.problematicReviews.length > 0) {
                            pendingReviews = pendingReviews.concat(validation.problematicReviews);
                            showReviewModal(validation.problematicReviews, sourceName);
                        } else {
                            let message = `✅ Successfully loaded ${duplicateCheck.unique.length} reviews from "${sourceName}". All reviews were automatically processed.`;
                            if (duplicateCheck.duplicates.length > 0) {
                                message += `\n\n📝 Note: ${duplicateCheck.duplicates.length} duplicate reviews were automatically skipped.`;
                            }
                            alert(message);
                        }

                    } catch (error) {
                        alert('Error parsing file: ' + error.message);
                    }
                };

                reader.readAsText(file);
            } else {
                alert('API integration not yet implemented');
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });
                    data.push(row);
                }
            }

            return data;
        }

        function validateDataStructure(data) {
            if (!Array.isArray(data) || data.length === 0) {
                return { valid: false, validReviews: [], problematicReviews: [] };
            }

            const requiredFields = ['date', 'content']; // Only date and content are required
            const validReviews = [];
            const problematicReviews = [];

            data.forEach((review, index) => {
                const hasRequiredFields = requiredFields.every(field => 
                    review.hasOwnProperty(field) && review[field] && review[field].toString().trim() !== ''
                );

                // Check for potential column assignment issues
                const columnIssues = detectColumnIssues(review);

                if (hasRequiredFields && columnIssues.length === 0) {
                    validReviews.push(review);
                } else {
                    const issues = requiredFields.filter(field => 
                        !review.hasOwnProperty(field) || !review[field] || review[field].toString().trim() === ''
                    );
                    
                    // Add column assignment issues to the main issues list
                    const allIssues = [...issues, ...columnIssues];
                    
                    problematicReviews.push({
                        index: index + 1, // 1-based index for user display
                        data: review,
                        issues: allIssues,
                        columnIssues: columnIssues
                    });
                }
            });

            return {
                valid: validReviews.length > 0,
                validReviews: validReviews,
                problematicReviews: problematicReviews
            };
        }

        function detectColumnIssues(review) {
            const issues = [];
            
            // Check if content looks like it might be in the wrong column
            const content = review.content || '';
            const source = review.source || '';
            const author = review.author || '';
            const rating = review.rating || '';
            
            // Check if rating column contains text that looks like content
            if (rating && rating.length > 50 && !/^\d+$/.test(rating.toString().trim())) {
                issues.push('rating-column-might-contain-content');
            }
            
            // Check if source column contains text that looks like content
            if (source && source.length > 50 && !/^(app_store|google_play|freshdesk|google_forms|survey|unknown)$/i.test(source)) {
                issues.push('source-column-might-contain-content');
            }
            
            // Check if author column contains text that looks like content
            if (author && author.length > 50 && !/^[a-zA-Z\s]+$/.test(author)) {
                issues.push('author-column-might-contain-content');
            }
            
            return issues;
        }

        function analyzeUserType(message, author) {
            if (!message) return 'unknown';
            
            const messageLower = message.toLowerCase();
            const authorLower = (author || '').toLowerCase();
            
            // Premium indicators
            const premiumKeywords = [
                'premium', 'pro', 'paid', 'subscription', 'upgrade', 'paid version',
                'buy', 'purchase', 'paid user', 'pro user', 'premium user'
            ];
            
            // Free indicators
            const freeKeywords = [
                'free', 'free version', 'free user', 'trial', 'free trial',
                'upgrade to', 'consider upgrading', 'free tier'
            ];
            
            const combinedText = messageLower + ' ' + authorLower;
            
            if (premiumKeywords.some(keyword => combinedText.includes(keyword))) {
                return 'premium';
            }
            
            if (freeKeywords.some(keyword => combinedText.includes(keyword))) {
                return 'free';
            }
            
            return 'unknown';
        }

        function extractKeywords(message) {
            if (!message) return [];
            
            // Common feature keywords to look for
            const featureKeywords = [
                'performance', 'speed', 'fast', 'slow', 'lag', 'crash', 'bug', 'error',
                'interface', 'ui', 'design', 'layout', 'navigation', 'menu',
                'notification', 'alert', 'reminder', 'push notification',
                'sync', 'backup', 'export', 'import', 'download', 'upload',
                'search', 'filter', 'sort', 'organize', 'categorize',
                'security', 'privacy', 'password', 'login', 'authentication',
                'offline', 'online', 'internet', 'connection', 'network',
                'customization', 'settings', 'preferences', 'configuration',
                'support', 'help', 'documentation', 'tutorial', 'guide',
                'update', 'upgrade', 'version', 'new feature', 'improvement',
                'pricing', 'cost', 'price', 'expensive', 'cheap', 'value',
                'mobile', 'desktop', 'web', 'app', 'application',
                'integration', 'api', 'third party', 'plugin', 'addon'
            ];
            
            const messageLower = message.toLowerCase();
            const foundKeywords = [];
            
            featureKeywords.forEach(keyword => {
                if (messageLower.includes(keyword)) {
                    foundKeywords.push(keyword);
                }
            });
            
            return foundKeywords;
        }

        function extractRating(message) {
            if (!message) return null;
            
            // Look for explicit ratings
            const ratingPatterns = [
                /(\d+)\s*\/\s*5/i,
                /(\d+)\s*out\s*of\s*5/i,
                /(\d+)\s*stars?/i,
                /rating[:\s]*(\d+)/i,
                /(\d+)\s*\/\s*10/i
            ];
            
            for (const pattern of ratingPatterns) {
                const match = message.match(pattern);
                if (match) {
                    let rating = parseInt(match[1]);
                    if (rating > 10) rating = Math.round(rating / 2); // Convert 10-point to 5-point
                    if (rating >= 1 && rating <= 5) return rating;
                }
            }
            
            // Look for sentiment-based ratings
            const positiveWords = ['excellent', 'amazing', 'perfect', 'outstanding', 'fantastic', 'brilliant'];
            const negativeWords = ['terrible', 'awful', 'horrible', 'worst', 'disappointing', 'useless'];
            
            const messageLower = message.toLowerCase();
            
            if (positiveWords.some(word => messageLower.includes(word))) {
                return 5;
            }
            
            if (negativeWords.some(word => messageLower.includes(word))) {
                return 1;
            }
            
            return null;
        }

        function generateKeywordTags() {
            const keywordTags = document.getElementById('keywordTags');
            keywordTags.innerHTML = `
                <span class="badge bg-light text-dark me-2 mb-2" style="cursor: pointer; border: 1px solid var(--light-gray);" onclick="addKeywordFilter('')">
                    <i class="fas fa-times me-1"></i>Clear All
                </span>
            `;
            
            // Get all managed keywords from customKeywords
            const managedKeywords = [
                ...customKeywords.competitors,
                ...customKeywords.golfFeatures,
                ...customKeywords.featureRequests
            ];
            
            if (managedKeywords.length === 0) {
                keywordTags.innerHTML += '<span class="text-muted small">No keywords managed yet. Add keywords in Keywords tab.</span>';
                return;
            }
            
            // Count keyword frequency for ALL managed keywords (including 0 mentions)
            const keywordCounts = {};
            managedKeywords.forEach(keyword => {
                keywordCounts[keyword] = 0; // Initialize all to 0
            });
            
            // Count actual mentions
            allReviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                managedKeywords.forEach(keyword => {
                    if (content.includes(keyword.toLowerCase())) {
                        keywordCounts[keyword] = (keywordCounts[keyword] || 0) + 1;
                    }
                });
            });
            
            // Sort by frequency (highest first) but show ALL keywords
            const sortedKeywords = Object.entries(keywordCounts)
                .sort(([,a], [,b]) => b - a);
            
            sortedKeywords.forEach(([keyword, count]) => {
                const badge = document.createElement('span');
                badge.className = 'badge bg-light text-dark me-2 mb-2';
                badge.style.cssText = 'cursor: pointer; border: 1px solid var(--light-gray);';
                badge.innerHTML = `${keyword} (${count})`;
                badge.onclick = () => addKeywordFilter(keyword);
                keywordTags.appendChild(badge);
            });
        }

        function addKeywordFilter(keyword) {
            if (keyword === '') {
                document.getElementById('keywordSearch').value = '';
            } else {
                document.getElementById('keywordSearch').value = keyword;
            }
            applyFilters();
        }

        function updateSourceCount() {
            const sourcesCountElement = document.getElementById('sources-count');
            if (sourcesCountElement) {
                sourcesCountElement.textContent = dataSources.length;
            }
        }

        function updateSourceList() {
            const container = document.getElementById('sourcesContainer');
            container.innerHTML = '';

            dataSources.forEach(source => {
                const sourceCard = document.createElement('div');
                sourceCard.className = 'col-lg-3 col-md-6 mb-3';
                sourceCard.innerHTML = `
                    <div class="source-card active" data-source="${source.id}">
                        <i class="fas fa-file-${source.type === 'csv' ? 'csv' : source.type === 'json' ? 'code' : 'excel'} fa-3x mb-3" style="color: var(--primary-black);"></i>
                        <h6 class="fw-bold">${source.name}</h6>
                        <span class="badge bg-success mb-2">Active</span>
                        <p class="small mb-2">${source.data.length} reviews</p>
                        <div class="btn-group w-100">
                            <button class="btn btn-sm btn-outline-primary" onclick="editSource(${source.id})">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" onclick="removeSource(${source.id})">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
                container.appendChild(sourceCard);
            });
        }

        function updateSourceFilter() {
            const sourceFilter = document.getElementById('sourceFilter');
            sourceFilter.innerHTML = '<option value="">All Sources</option>';
            
            const uniqueSources = [...new Set(allReviews.map(r => r.source))];
            uniqueSources.forEach(source => {
                const option = document.createElement('option');
                option.value = source;
                option.textContent = source;
                sourceFilter.appendChild(option);
            });
        }

        function updateReviewsTable() {
            const tbody = document.getElementById('reviewsTableBody');
            tbody.innerHTML = '';

            // Use current filtered reviews if available, otherwise use all reviews
            const reviewsToShow = currentFilteredReviews.length > 0 ? currentFilteredReviews : allReviews;
            console.log(`updateReviewsTable: Showing ${reviewsToShow.length} reviews (filtered: ${currentFilteredReviews.length > 0})`);

            if (reviewsToShow.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="8" class="text-center" style="color: var(--medium-gray); padding: 3rem;">
                            <i class="fas fa-database fa-3x mb-3"></i>
                            <p>No data loaded. Upload CSV files in the Data Sources tab.</p>
                        </td>
                    </tr>
                `;
                return;
            }

            // Calculate pagination
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            const paginatedReviews = reviewsToShow.slice(startIndex, endIndex);

            paginatedReviews.forEach(review => {
                const userType = review.userType || analyzeUserType(review.content, review.author);
                const extractedRating = extractRating(review.content) || review.rating;
                const keywords = extractKeywords(review.content);
                const editedBadge = review.edited ? '<span class="badge bg-warning text-dark ms-1">edited</span>' : '';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${review.date || 'N/A'}</td>
                    <td><span class="badge badge-source">${review.source || 'Unknown'}</span></td>
                    <td>${review.author || 'Anonymous'}</td>
                    <td><span class="badge ${userType === 'premium' ? 'bg-dark' : userType === 'free' ? 'bg-light text-dark' : 'bg-secondary'}">${userType}</span></td>
                    <td>${(review.content || '').substring(0, 150)}${(review.content || '').length > 150 ? '...' : ''}${editedBadge}</td>
                    <td>${extractedRating ? generateStars(extractedRating) : 'N/A'}</td>
                    <td>${keywords.length > 0 ? keywords.slice(0, 3).map(k => `<span class="badge bg-light text-dark me-1">${k}</span>`).join('') : 'None'}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary" onclick="viewEditReview(${JSON.stringify(review).replace(/"/g, '&quot;')})">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });
            
            // Generate keyword tags after updating table
            generateKeywordTags();
        }

        function generateStars(rating) {
            const cleanRating = parseFloat(rating);
            if (isNaN(cleanRating) || cleanRating < 1 || cleanRating > 5) {
                return `<span class="badge bg-light text-dark" style="border: 1px solid var(--github-border);">N/A</span>`;
            }
            return `<span class="badge bg-light text-dark" style="border: 1px solid var(--github-border);">${Math.round(cleanRating * 10) / 10}</span>`;
        }

        function applyFilters() {
            const sourceFilter = document.getElementById('sourceFilter').value;
            const userTypeFilter = document.getElementById('userTypeFilter').value;
            const ratingFilter = document.getElementById('ratingFilter').value;
            const keywordSearch = document.getElementById('keywordSearch').value.toLowerCase();
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;

            let filteredReviews = allReviews.filter(review => {
                if (sourceFilter && review.source !== sourceFilter) return false;
                
                // Check user type
                if (userTypeFilter) {
                    const userType = analyzeUserType(review.content, review.author);
                    if (userType !== userTypeFilter) return false;
                }
                
                // Check rating (both extracted and original)
                if (ratingFilter) {
                    const extractedRating = extractRating(review.content) || review.rating;
                    if (extractedRating != ratingFilter) return false;
                }
                
                if (keywordSearch && !review.content.toLowerCase().includes(keywordSearch)) return false;
                if (startDate && review.date < startDate) return false;
                if (endDate && review.date > endDate) return false;
                return true;
            });

            // Update results count
            document.getElementById('resultsCount').textContent = filteredReviews.length;
            
            // Update filter summary
            const filters = [];
            if (sourceFilter) filters.push(`Source: ${sourceFilter}`);
            if (userTypeFilter) filters.push(`User Type: ${userTypeFilter}`);
            if (ratingFilter) filters.push(`Rating: ${ratingFilter} stars`);
            if (keywordSearch) filters.push(`Keyword: "${keywordSearch}"`);
            
            document.getElementById('filterSummary').textContent = 
                filters.length > 0 ? `Filters: ${filters.join(', ')}` : '';

            // Update table with filtered data
            updateFilteredTable(filteredReviews);
        }

        function updateFilteredTable(reviews) {
            const tbody = document.getElementById('reviewsTableBody');
            tbody.innerHTML = '';

            // Calculate pagination
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            const paginatedReviews = reviews.slice(startIndex, endIndex);

            paginatedReviews.forEach(review => {
                const userType = review.userType || analyzeUserType(review.content, review.author);
                const extractedRating = extractRating(review.content) || review.rating;
                const keywords = extractKeywords(review.content);
                const editedBadge = review.edited ? '<span class="badge bg-warning text-dark ms-1">edited</span>' : '';
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${review.date || 'N/A'}</td>
                    <td><span class="badge badge-source">${review.source || 'Unknown'}</span></td>
                    <td>${review.author || 'Anonymous'}</td>
                    <td><span class="badge ${userType === 'premium' ? 'bg-dark' : userType === 'free' ? 'bg-light text-dark' : 'bg-secondary'}">${userType}</span></td>
                    <td>${(review.content || '').substring(0, 150)}${(review.content || '').length > 150 ? '...' : ''}${editedBadge}</td>
                    <td>${extractedRating ? generateStars(extractedRating) : 'N/A'}</td>
                    <td>${keywords.length > 0 ? keywords.slice(0, 3).map(k => `<span class="badge bg-light text-dark me-1">${k}</span>`).join('') : 'None'}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary" onclick="viewEditReview(${JSON.stringify(review).replace(/"/g, '&quot;')})">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function sortByColumn(column) {
            let direction = 'asc';
            
            // If clicking the same column, toggle direction
            if (currentSortColumn === column) {
                direction = currentSortDirection === 'asc' ? 'desc' : 'asc';
            }
            
            // Update sort state
            currentSortColumn = column;
            currentSortDirection = direction;
            
            // Update arrow indicators
            updateSortArrows(column, direction);
            
            // Sort the reviews
            let sortedReviews = [...currentFilteredReviews];
            
            if (column === 'date') {
                sortedReviews.sort((a, b) => {
                    const dateA = new Date(a.date || 0);
                    const dateB = new Date(b.date || 0);
                    return direction === 'asc' ? dateA - dateB : dateB - dateA;
                });
            } else if (column === 'rating') {
                sortedReviews.sort((a, b) => {
                    const ratingA = extractRating(a.content) || a.rating || 0;
                    const ratingB = extractRating(b.content) || b.rating || 0;
                    return direction === 'asc' ? ratingA - ratingB : ratingB - ratingA;
                });
            }
            
            updateFilteredTable(sortedReviews);
            updatePagination();
        }

        function updateSortArrows(activeColumn, direction) {
            // Reset all arrows
            const dateArrow = document.getElementById('date-sort-arrow');
            const ratingArrow = document.getElementById('rating-sort-arrow');
            
            dateArrow.className = 'sort-arrow';
            ratingArrow.className = 'sort-arrow';
            
            // Set active arrow
            if (activeColumn === 'date') {
                dateArrow.className = `sort-arrow active ${direction}`;
            } else if (activeColumn === 'rating') {
                ratingArrow.className = `sort-arrow active ${direction}`;
            }
        }

        function applyCustomDateRange() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            if (start > end) {
                alert('Start date must be before end date');
                return;
            }
            
            // Filter reviews by custom date range
            const filteredReviews = allReviews.filter(review => {
                const reviewDate = new Date(review.date);
                return reviewDate >= start && reviewDate <= end;
            });
            
            currentFilteredReviews = filteredReviews;
            currentPage = 1; // Reset to first page
            
            // Clear time period selections
            document.querySelectorAll('input[name="timePeriodList"]').forEach(radio => {
                radio.checked = false;
            });
            
            updateFilteredTable(filteredReviews);
            updatePagination();
            
            // Update results count
            document.getElementById('resultsCount').textContent = filteredReviews.length;
            document.getElementById('filterSummary').textContent = `Custom Date Range: ${startDate} to ${endDate}`;
            
            // Close dropdown
            const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('customDateRangeDropdown'));
            if (dropdown) dropdown.hide();
        }

        function clearCustomDateRange() {
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            
            // Reset to all time
            document.getElementById('allTimeList').checked = true;
            currentFilteredReviews = allReviews;
            currentPage = 1;
            
            updateFilteredTable(allReviews);
            updatePagination();
            
            // Update results count
            document.getElementById('resultsCount').textContent = allReviews.length;
            document.getElementById('filterSummary').textContent = '';
            
            // Close dropdown
            const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('customDateRangeDropdown'));
            if (dropdown) dropdown.hide();
        }

        function changePageSize() {
            pageSize = parseInt(document.getElementById('pageSizeSelect').value);
            currentPage = 1; // Reset to first page
            updatePagination();
            updateFilteredTable(currentFilteredReviews);
        }

        function updatePagination() {
            const totalItems = currentFilteredReviews.length;
            totalPages = Math.ceil(totalItems / pageSize);
            
            // Update pagination info
            const startItem = (currentPage - 1) * pageSize + 1;
            const endItem = Math.min(currentPage * pageSize, totalItems);
            document.getElementById('paginationInfo').textContent = `Showing ${startItem}-${endItem} of ${totalItems}`;
            
            // Generate pagination controls
            const paginationControls = document.getElementById('paginationControls');
            paginationControls.innerHTML = '';
            
            if (totalPages <= 1) return;
            
            // Previous button
            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
            prevLi.innerHTML = `<a class="page-link" href="#" onclick="goToPage(${currentPage - 1})">Previous</a>`;
            paginationControls.appendChild(prevLi);
            
            // Page numbers
            const startPage = Math.max(1, currentPage - 2);
            const endPage = Math.min(totalPages, currentPage + 2);
            
            if (startPage > 1) {
                const firstLi = document.createElement('li');
                firstLi.className = 'page-item';
                firstLi.innerHTML = `<a class="page-link" href="#" onclick="goToPage(1)">1</a>`;
                paginationControls.appendChild(firstLi);
                
                if (startPage > 2) {
                    const ellipsisLi = document.createElement('li');
                    ellipsisLi.className = 'page-item disabled';
                    ellipsisLi.innerHTML = '<span class="page-link">...</span>';
                    paginationControls.appendChild(ellipsisLi);
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const li = document.createElement('li');
                li.className = `page-item ${i === currentPage ? 'active' : ''}`;
                li.innerHTML = `<a class="page-link" href="#" onclick="goToPage(${i})">${i}</a>`;
                paginationControls.appendChild(li);
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const ellipsisLi = document.createElement('li');
                    ellipsisLi.className = 'page-item disabled';
                    ellipsisLi.innerHTML = '<span class="page-link">...</span>';
                    paginationControls.appendChild(ellipsisLi);
                }
                
                const lastLi = document.createElement('li');
                lastLi.className = 'page-item';
                lastLi.innerHTML = `<a class="page-link" href="#" onclick="goToPage(${totalPages})">${totalPages}</a>`;
                paginationControls.appendChild(lastLi);
            }
            
            // Next button
            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
            nextLi.innerHTML = `<a class="page-link" href="#" onclick="goToPage(${currentPage + 1})">Next</a>`;
            paginationControls.appendChild(nextLi);
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages || page === currentPage) return;
            
            currentPage = page;
            updatePagination();
            updateFilteredTable(currentFilteredReviews);
        }

        function clearFilters() {
            document.getElementById('sourceFilter').value = '';
            document.getElementById('userTypeFilter').value = '';
            document.getElementById('ratingFilter').value = '';
            document.getElementById('keywordSearch').value = '';
            document.getElementById('startDate').value = '';
            document.getElementById('endDate').value = '';
            
            // Reset sorting
            currentSortColumn = null;
            currentSortDirection = null;
            updateSortArrows(null, null);
            
            // Reset pagination
            currentPage = 1;
            
            document.getElementById('resultsCount').textContent = allReviews.length;
            document.getElementById('filterSummary').textContent = '';
            
            updateReviewsTable();
            updatePagination();
        }

        function removeSource(sourceId) {
            if (confirm('Are you sure you want to remove this data source? All reviews from this source will also be deleted.')) {
                const sourceIndex = dataSources.findIndex(s => s.id === sourceId);
                if (sourceIndex !== -1) {
                    const source = dataSources[sourceIndex];
                    
                    // Remove reviews from this source by comparing review objects
                    const sourceReviewIds = new Set(source.data.map(r => JSON.stringify(r)));
                    allReviews = allReviews.filter(r => !sourceReviewIds.has(JSON.stringify(r)));
                    
                    // Remove the source
                    dataSources.splice(sourceIndex, 1);
                    
                    // Also remove from pending and reviewed reviews
                    pendingReviews = pendingReviews.filter(r => !sourceReviewIds.has(JSON.stringify(r)));
                    reviewedReviews = reviewedReviews.filter(r => !sourceReviewIds.has(JSON.stringify(r)));
                    
                    // Save to localStorage
                    saveToStorage();
                    
                    // Update UI
                    updateSourceCount();
                    updateSourceList();
                    updateDashboardMetrics(allReviews);
                    updateReviewsTable();
                    updateSourceFilter();
                    updatePendingCount();
                    
                    alert(`✅ Data source "${source.name}" and its ${source.data.length} reviews have been removed successfully!`);
                }
            }
        }

        function editSource(sourceId) {
            alert('Edit functionality not yet implemented');
        }

        function viewReview(date, source) {
            alert(`Viewing review from ${date} (${source})`);
        }

        function updateTime() {
            const now = new Date();
            document.getElementById('last-updated').textContent = now.toLocaleString();
        }

        function showReviewModal(problematicReviews, sourceName) {
            console.log('Showing review modal with:', problematicReviews);
            document.getElementById('reviewMessage').textContent = 
                `${problematicReviews.length} reviews from "${sourceName}" couldn't be automatically processed and need your review.`;
            document.getElementById('pendingCount').textContent = pendingReviews.length;
            
            const container = document.getElementById('reviewContainer');
            container.innerHTML = '';
            
            problematicReviews.forEach((review, index) => {
                const reviewItem = document.createElement('div');
                reviewItem.className = 'card mb-3';
                reviewItem.innerHTML = `
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-file-alt me-2"></i>
                            Review ${index + 1} (Row ${review.index})
                        </h6>
                        <small class="text-muted">
                            ${review.issues.includes('date') ? 'Missing date • ' : ''}
                            ${review.issues.includes('content') ? 'Missing content • ' : ''}
                            ${review.columnIssues && review.columnIssues.includes('rating-column-might-contain-content') ? 'Rating column might contain message content • ' : ''}
                            ${review.columnIssues && review.columnIssues.includes('source-column-might-contain-content') ? 'Source column might contain message content • ' : ''}
                            ${review.columnIssues && review.columnIssues.includes('author-column-might-contain-content') ? 'Author column might contain message content • ' : ''}
                        </small>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <label class="form-label">Date <span class="text-danger">*</span></label>
                                <input type="date" class="form-control" id="date_${index}" value="${review.data.date || ''}">
                                <small class="text-muted">Required: When the review was written</small>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label">Source</label>
                                <input type="text" class="form-control" id="source_${index}" value="${review.data.source || ''}" placeholder="e.g., app_store, google_play">
                                <small class="text-muted">Where the review came from (app store, support, etc.)</small>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <label class="form-label">Author/User Name</label>
                                <input type="text" class="form-control" id="author_${index}" value="${review.data.author || ''}" placeholder="User name or Anonymous">
                                <small class="text-muted">Name of the person who wrote the review</small>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label">Rating</label>
                                <select class="form-select" id="rating_${index}">
                                    <option value="">No rating</option>
                                    <option value="1" ${review.data.rating == 1 ? 'selected' : ''}>1 star</option>
                                    <option value="2" ${review.data.rating == 2 ? 'selected' : ''}>2 stars</option>
                                    <option value="3" ${review.data.rating == 3 ? 'selected' : ''}>3 stars</option>
                                    <option value="4" ${review.data.rating == 4 ? 'selected' : ''}>4 stars</option>
                                    <option value="5" ${review.data.rating == 5 ? 'selected' : ''}>5 stars</option>
                                </select>
                                <small class="text-muted">Star rating (1-5) - should be a number only</small>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-12">
                                <label class="form-label">Message/Content <span class="text-danger">*</span></label>
                                <textarea class="form-control" id="content_${index}" rows="3" placeholder="Review content...">${review.data.content || ''}</textarea>
                                <small class="text-muted">Required: The actual review text or comment</small>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-12">
                                <button class="btn btn-sm btn-outline-danger" onclick="removeReview(${index})">
                                    <i class="fas fa-trash me-1"></i>Remove Review
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(reviewItem);
            });
            
            const modal = new bootstrap.Modal(document.getElementById('reviewModal'));
            modal.show();
        }

        function skipAllReviews() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('reviewModal'));
            modal.hide();
            
            // Remove all pending reviews from this session (they were explicitly skipped)
            pendingReviews = [];
            saveToStorage();
            updatePendingCount();
            
            alert(`⏰ All reviews skipped. No reviews were added to the system.`);
        }

        function saveReviews() {
            const container = document.getElementById('reviewContainer');
            const reviewItems = container.querySelectorAll('.card');
            const newValidReviews = [];
            const remainingPendingReviews = [];
            const totalInModal = reviewItems.length;
            
            reviewItems.forEach((item, index) => {
                const date = document.getElementById(`date_${index}`).value;
                const content = document.getElementById(`content_${index}`).value;
                
                if (date && content.trim()) {
                    const review = {
                        date: date,
                        content: content.trim(),
                        source: document.getElementById(`source_${index}`).value || 'unknown',
                        author: document.getElementById(`author_${index}`).value || 'Anonymous',
                        rating: document.getElementById(`rating_${index}`).value || null,
                        edited: true // Mark as manually edited
                    };
                    
                    newValidReviews.push(review);
                    reviewedReviews.push(review);
                } else {
                    // Keep incomplete reviews as pending
                    remainingPendingReviews.push(pendingReviews[index]);
                }
            });
            
            // Add the reviewed reviews to the main dataset
            allReviews = allReviews.concat(newValidReviews);
            currentFilteredReviews = allReviews; // Update filtered reviews to show all
            
            // Update pending reviews - remove the ones that were in this modal, add back the incomplete ones
            pendingReviews = pendingReviews.slice(totalInModal).concat(remainingPendingReviews);
            
            // Save to localStorage
            saveToStorage();
            
            // Update UI
            updateDashboardMetrics(allReviews);
            updateReviewsTable();
            updateSourceFilter();
            updatePendingCount();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('reviewModal'));
            modal.hide();
            
            // Show appropriate message based on what happened
            if (newValidReviews.length === totalInModal) {
                // All reviews in the modal were completed
                alert(`✅ Successfully saved ${newValidReviews.length} reviews to the system. These reviews are now marked as "edited" in the table.`);
            } else if (newValidReviews.length > 0) {
                // Some reviews were saved, some still need review
                alert(`✅ Successfully saved ${newValidReviews.length} reviews to the system. ${remainingPendingReviews.length} reviews still need review and will remain in the notification above the table.`);
            } else {
                // No reviews were saved (all still need review)
                alert(`⏰ No reviews were saved. All ${totalInModal} reviews still need review and are shown in the notification above the table.`);
            }
        }

        function removeReview(index) {
            if (confirm('Are you sure you want to remove this review?')) {
                const container = document.getElementById('reviewContainer');
                const reviewItems = container.querySelectorAll('.card');
                if (reviewItems[index]) {
                    reviewItems[index].remove();
                }
            }
        }

        function updatePendingCount() {
            const pendingCount = pendingReviews.length;
            const indicator = document.getElementById('pendingIndicator');
            const badge = document.getElementById('pendingCountBadge');
            const listAlert = document.getElementById('pendingReviewsAlert');
            const listCount = document.getElementById('pendingReviewsCount');
            
            if (pendingCount > 0) {
                indicator.style.display = 'inline';
                badge.textContent = pendingCount;
                listAlert.style.display = 'block';
                listCount.textContent = pendingCount;
            } else {
                indicator.style.display = 'none';
                listAlert.style.display = 'none';
            }
        }

        function showPendingReviews() {
            if (pendingReviews.length > 0) {
                showReviewModal(pendingReviews, 'Pending Reviews');
            }
        }

        // Global variable to store the current review being edited
        let currentEditingReview = null;
        let currentEditingIndex = -1;

        function viewEditReview(review) {
            currentEditingReview = review;
            currentEditingIndex = allReviews.findIndex(r => 
                r.date === review.date && 
                r.content === review.content && 
                r.source === review.source
            );
            
            // Populate the form with review data
            document.getElementById('editDate').value = review.date || '';
            document.getElementById('editSource').value = review.source || '';
            document.getElementById('editAuthor').value = review.author || '';
            document.getElementById('editRating').value = review.rating || '';
            document.getElementById('editContent').value = review.content || '';
            
            // Show review information
            const userType = analyzeUserType(review.content, review.author);
            const keywords = extractKeywords(review.content);
            const info = `
                <strong>Previously Edited:</strong> ${review.edited ? 'Yes' : 'No'} • 
                <strong>Source:</strong> ${review.source || 'Unknown'} • 
                <strong>Total Keywords:</strong> ${keywords.length}
            `;
            document.getElementById('editReviewInfo').innerHTML = info;
            
            // Set user type dropdown (use stored value or system analysis)
            document.getElementById('editUserType').value = review.userType || userType;
            
            // Display user type analysis indicators
            displayUserTypeAnalysisIndicators(userType, review);
            
            // Display keywords cloud
            displayKeywordsCloud(keywords);
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('viewEditModal'));
            modal.show();
        }

        function saveEditedReview() {
            const date = document.getElementById('editDate').value;
            const content = document.getElementById('editContent').value;
            
            if (!date || !content.trim()) {
                alert('Please fill in the required fields (Date and Content)');
                return;
            }
            
            if (currentEditingIndex === -1) {
                alert('Error: Could not find review to update');
                return;
            }
            
            // Update the review
            const updatedReview = {
                date: date,
                content: content.trim(),
                source: document.getElementById('editSource').value || 'unknown',
                author: document.getElementById('editAuthor').value || 'Anonymous',
                rating: document.getElementById('editRating').value || null,
                userType: document.getElementById('editUserType').value, // Include user type
                edited: true // Mark as manually edited
            };
            
            // Replace the review in the array
            allReviews[currentEditingIndex] = updatedReview;
            
            // Update UI
            updateDashboardMetrics(allReviews);
            updateReviewsTable();
            updateSourceFilter();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('viewEditModal'));
            modal.hide();
            
            alert('✅ Review updated successfully! Changes are now reflected in the table.');
        }

        function deleteReview() {
            if (confirm('Are you sure you want to delete this review? This action cannot be undone.')) {
                if (currentEditingIndex === -1) {
                    alert('Error: Could not find review to delete');
                    return;
                }
                
                // Remove the review from the array
                allReviews.splice(currentEditingIndex, 1);
                
                // Update UI
                updateDashboardMetrics(allReviews);
                updateReviewsTable();
                updateSourceFilter();
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('viewEditModal'));
                modal.hide();
                
                alert('✅ Review deleted successfully!');
            }
        }

        function displayUserTypeAnalysisIndicators(userType, review) {
            const container = document.getElementById('editUserTypeAnalysis');
            
            let confidence = 'Low';
            
            if (userType === 'premium') {
                confidence = 'High';
            } else if (userType === 'free') {
                confidence = 'Medium';
            }
            
            // Get user type indicators from the review content
            const indicators = getUserTypeIndicators(review.content);
            
            container.innerHTML = `
                <div class="alert alert-light">
                    <h6 class="mb-2">
                        <i class="fas fa-brain me-2"></i>
                        System Analysis
                    </h6>
                    <div class="mb-2">
                        <span class="badge bg-info text-white me-2">Suggested: ${userType.toUpperCase()}</span>
                        <span class="badge bg-secondary">Confidence: ${confidence}</span>
                    </div>
                    <div class="mt-3">
                        <h6 class="mb-2">Analysis Indicators:</h6>
                        ${indicators.length > 0 ? 
                            indicators.map(indicator => `<div class="mb-1"><i class="fas fa-check text-success me-2"></i><small>${indicator}</small></div>`).join('') :
                            '<div class="text-muted"><small>No specific indicators found</small></div>'
                        }
                    </div>
                    <div class="mt-2">
                        <small class="text-muted">
                            <i class="fas fa-info-circle me-1"></i>
                            You can override the system's suggestion using the dropdown above
                        </small>
                    </div>
                </div>
            `;
        }

        function getUserTypeIndicators(content) {
            const indicators = [];
            const contentLower = content.toLowerCase();
            
            // Premium indicators
            if (contentLower.includes('premium') || contentLower.includes('pro') || contentLower.includes('paid')) {
                indicators.push('Mentions premium/pro features');
            }
            if (contentLower.includes('subscription') || contentLower.includes('upgrade')) {
                indicators.push('References subscription/upgrade');
            }
            if (contentLower.includes('worth the money') || contentLower.includes('value for money')) {
                indicators.push('Discusses pricing value');
            }
            
            // Free indicators
            if (contentLower.includes('free') || contentLower.includes('trial')) {
                indicators.push('Mentions free/trial usage');
            }
            if (contentLower.includes('limited') || contentLower.includes('basic')) {
                indicators.push('References limited features');
            }
            
            return indicators;
        }

        function displayKeywordsCloud(keywords) {
            const container = document.getElementById('editKeywordsCloud');
            
            if (keywords.length === 0) {
                container.innerHTML = '<div class="text-center text-muted"><small>No keywords detected</small></div>';
                return;
            }
            
            // Sort keywords by frequency (if available) or alphabetically
            const sortedKeywords = keywords.sort();
            
            // Create keyword cloud with different sizes based on position
            const keywordCloud = sortedKeywords.slice(0, 15).map((keyword, index) => {
                let sizeClass = 'fs-6'; // Default size
                let badgeClass = 'bg-light text-dark';
                
                // Different sizes for visual hierarchy
                if (index < 3) {
                    sizeClass = 'fs-5';
                    badgeClass = 'bg-primary text-white';
                } else if (index < 6) {
                    sizeClass = 'fs-6';
                    badgeClass = 'bg-info text-white';
                } else if (index < 10) {
                    sizeClass = 'fs-6';
                    badgeClass = 'bg-light text-dark';
                } else {
                    sizeClass = 'fs-7';
                    badgeClass = 'bg-secondary text-white';
                }
                
                return `<span class="badge ${badgeClass} me-1 mb-1 ${sizeClass}">${keyword}</span>`;
            }).join('');
            
            container.innerHTML = `
                <div class="mb-3">
                    ${keywordCloud}
                </div>
                ${keywords.length > 15 ? 
                    `<div class="text-center">
                        <small class="text-muted">Showing top 15 of ${keywords.length} keywords</small>
                    </div>` : 
                    ''
                }
                <div class="mt-2">
                    <small class="text-muted">
                        <i class="fas fa-info-circle me-1"></i>
                        Keywords are extracted from review content using smart analysis
                    </small>
                </div>
            `;
        }

        // Advanced Analytics Helper Functions
        function extractAllKeywords(reviews) {
            const keywordCounts = {};
            
            reviews.forEach(review => {
                const keywords = extractKeywords(review.content);
                keywords.forEach(keyword => {
                    keywordCounts[keyword] = (keywordCounts[keyword] || 0) + 1;
                });
            });
            
            return keywordCounts;
        }

        function extractPainPoints(reviews) {
            const painPointPatterns = [
                /(?:bug|bugs|broken|crash|crashes|error|errors|issue|issues|problem|problems|slow|slowly|lag|laggy|freeze|freezes|glitch|glitches)/gi,
                /(?:difficult|hard|confusing|complicated|complex|frustrating|annoying|terrible|awful|horrible)/gi,
                /(?:missing|lack|need|want|wish|should|could|better|improve|fix)/gi,
                /(?:expensive|cost|price|money|waste|worthless|useless|bad|worst)/gi,
                /(?:support|customer service|help|response|reply)/gi
            ];
            
            const painPoints = {};
            
            reviews.forEach(review => {
                const content = review.content.toLowerCase();
                const rating = parseFloat(review.rating) || 0;
                
                // Only consider reviews with low ratings or negative sentiment
                if (rating <= 2 || content.includes('bad') || content.includes('terrible') || content.includes('awful')) {
                    painPointPatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const cleanMatch = match.toLowerCase().trim();
                                if (cleanMatch.length > 2) {
                                    painPoints[cleanMatch] = (painPoints[cleanMatch] || 0) + 1;
                                }
                            });
                        }
                    });
                }
            });
            
            return Object.entries(painPoints)
                .map(([text, count]) => ({ text, count }))
                .sort((a, b) => b.count - a.count);
        }

        function extractAdvantages(reviews) {
            const advantagePatterns = [
                /(?:great|good|excellent|amazing|awesome|fantastic|perfect|wonderful|brilliant|outstanding)/gi,
                /(?:love|like|enjoy|recommend|best|favorite|top|superior|quality|reliable)/gi,
                /(?:fast|quick|easy|simple|intuitive|user-friendly|smooth|stable|secure|safe)/gi,
                /(?:feature|features|function|functions|tool|tools|option|options|capability|capabilities)/gi,
                /(?:free|cheap|affordable|value|worth|benefit|benefits|advantage|advantages)/gi
            ];
            
            const advantages = {};
            
            reviews.forEach(review => {
                const content = review.content.toLowerCase();
                const rating = parseFloat(review.rating) || 0;
                
                // Only consider reviews with high ratings or positive sentiment
                if (rating >= 4 || content.includes('great') || content.includes('excellent') || content.includes('love')) {
                    advantagePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const cleanMatch = match.toLowerCase().trim();
                                if (cleanMatch.length > 2) {
                                    advantages[cleanMatch] = (advantages[cleanMatch] || 0) + 1;
                                }
                            });
                        }
                    });
                }
            });
            
            return Object.entries(advantages)
                .map(([text, count]) => ({ text, count }))
                .sort((a, b) => b.count - a.count);
        }

        function extractRequestedFeatures(reviews) {
            const featurePatterns = [
                /(?:add|need|want|wish|should|could|please|feature|function|option)/gi,
                /(?:support|compatibility|integration|sync|backup|export|import)/gi,
                /(?:notification|alert|reminder|calendar|schedule|timer)/gi,
                /(?:theme|color|design|layout|interface|ui|ux)/gi,
                /(?:language|translation|localization|region|country)/gi,
                /(?:dark mode|night mode|light mode|theme|appearance)/gi,
                /(?:offline|online|sync|cloud|storage|backup)/gi,
                /(?:widget|shortcut|gesture|voice|command|automation)/gi
            ];
            
            const features = {};
            
            reviews.forEach(review => {
                const content = review.content.toLowerCase();
                
                featurePatterns.forEach(pattern => {
                    const matches = content.match(pattern);
                    if (matches) {
                        matches.forEach(match => {
                            const cleanMatch = match.toLowerCase().trim();
                            if (cleanMatch.length > 2) {
                                features[cleanMatch] = (features[cleanMatch] || 0) + 1;
                            }
                        });
                    }
                });
            });
            
            return Object.entries(features)
                .map(([text, count]) => ({ text, count }))
                .sort((a, b) => b.count - a.count);
        }

        function getFilteredReviewsByPeriod(reviews) {
            // This would filter reviews based on the selected time period
            // For now, return all reviews
            return reviews;
        }

        function calculateKeywordTrends(reviews, keywords) {
            // Group reviews by week
            const weeklyData = {};
            const weeks = [];
            
            reviews.forEach(review => {
                if (review.date) {
                    const date = new Date(review.date);
                    const weekKey = getWeekKey(date);
                    
                    if (!weeklyData[weekKey]) {
                        weeklyData[weekKey] = { reviews: [], keywords: {} };
                        weeks.push(weekKey);
                    }
                    
                    weeklyData[weekKey].reviews.push(review);
                }
            });
            
            // Sort weeks
            weeks.sort();
            
            // Count keyword mentions per week
            const result = { weeks };
            keywords.forEach(keyword => {
                result[keyword] = weeks.map(week => {
                    const weekReviews = weeklyData[week]?.reviews || [];
                    return weekReviews.filter(review => 
                        review.content && review.content.toLowerCase().includes(keyword.toLowerCase())
                    ).length;
                });
            });
            
            return result;
        }

        function getWeekKey(date) {
            const year = date.getFullYear();
            const week = getWeekNumber(date);
            return `${year}-W${week.toString().padStart(2, '0')}`;
        }

        function getWeekNumber(date) {
            const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
            const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
            return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
        }

        // Keywords Manager Functions
        function showKeywordsManager() {
            loadKeywordsManager();
        }

        function showKeywordsTab() {
            // Switch to Keywords tab
            const keywordsTab = document.getElementById('keywords-tab');
            if (keywordsTab) {
                const tab = new bootstrap.Tab(keywordsTab);
                tab.show();
            }
        }

        function loadKeywordsManager() {
            // Calculate keyword frequencies
            const keywordFrequencies = calculateKeywordFrequencies();
            
            // Load competitors with frequency
            const competitorsContainer = document.getElementById('competitorsKeywords');
            competitorsContainer.innerHTML = customKeywords.competitors.map(keyword => {
                const frequency = keywordFrequencies[keyword.toLowerCase()] || 0;
                return `<span class="badge bg-danger me-1 mb-1">
                    ${keyword} (${frequency})
                    <button class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeKeyword('competitors', '${keyword}')"></button>
                </span>`;
            }).join('');

            // Load golf features with frequency
            const golfFeaturesContainer = document.getElementById('golfFeaturesKeywords');
            golfFeaturesContainer.innerHTML = customKeywords.golfFeatures.map(keyword => {
                const frequency = keywordFrequencies[keyword.toLowerCase()] || 0;
                return `<span class="badge bg-success me-1 mb-1">
                    ${keyword} (${frequency})
                    <button class="btn-close btn-close-white ms-1" style="font-size: 0.7em;" onclick="removeKeyword('golfFeatures', '${keyword}')"></button>
                </span>`;
            }).join('');

            // Load feature requests with frequency
            const featureRequestsContainer = document.getElementById('featureRequestsKeywords');
            featureRequestsContainer.innerHTML = customKeywords.featureRequests.map(keyword => {
                const frequency = keywordFrequencies[keyword.toLowerCase()] || 0;
                return `<span class="badge bg-warning text-dark me-1 mb-1">
                    ${keyword} (${frequency})
                    <button class="btn-close btn-close-dark ms-1" style="font-size: 0.7em;" onclick="removeKeyword('featureRequests', '${keyword}')"></button>
                </span>`;
            }).join('');

            // Update smart suggestions
            updateSmartSuggestions();
            
            // Update pain points analysis
            updatePainPointsAnalysis();
            
            // Update advantages analysis
            updateAdvantagesAnalysis();
            
            // Update filters in other tabs
            updateKeywordFilters();
        }

        function addKeyword(category, inputId) {
            const input = document.getElementById(inputId);
            const keyword = input.value.trim().toLowerCase();
            
            if (keyword && !customKeywords[category].includes(keyword)) {
                customKeywords[category].push(keyword);
                saveToStorage();
                loadKeywordsManager();
                input.value = '';
                
                // Update filters in Feedbacks List tab
                updateKeywordFilters();
            }
        }

        function removeKeyword(category, keyword) {
            const index = customKeywords[category].indexOf(keyword);
            if (index > -1) {
                customKeywords[category].splice(index, 1);
                saveToStorage();
                loadKeywordsManager();
                
                // Update filters in Feedbacks List tab
                updateKeywordFilters();
            }
        }

        function updateSmartSuggestions() {
            if (allReviews.length === 0) {
                document.getElementById('suggestedCompetitors').innerHTML = '<p class="text-muted small">Upload reviews to get suggestions</p>';
                document.getElementById('suggestedGolfTerms').innerHTML = '<p class="text-muted small">Upload reviews to get suggestions</p>';
                document.getElementById('suggestedFeatures').innerHTML = '<p class="text-muted small">Upload reviews to get suggestions</p>';
                return;
            }

            // Analyze reviews for suggestions
            const allText = allReviews.map(r => r.content).join(' ').toLowerCase();
            
            // Golf app competitor suggestions
            const competitorPatterns = [
                /(golfshot|18birdies|swingu|golfnow|golflogix|arccos|shot scope|the grint|golf pad|hole19)/gi
            ];
            
            const suggestedCompetitors = [];
            let match;
            while ((match = competitorPatterns[0].exec(allText)) !== null) {
                const competitor = match[0].toLowerCase();
                if (!customKeywords.competitors.includes(competitor) && !suggestedCompetitors.includes(competitor)) {
                    suggestedCompetitors.push(competitor);
                }
            }
            
            // Golf terms suggestions
            const golfTerms = [
                'handicap', 'par', 'birdie', 'eagle', 'bogey', 'double bogey', 'albatross', 'hole in one',
                'fairway', 'rough', 'green', 'bunker', 'water hazard', 'tee box', 'putting green',
                'driver', 'irons', 'wedge', 'putter', 'hybrid', 'wood', 'cart', 'caddie',
                'stroke play', 'match play', 'scramble', 'best ball', 'tournament', 'league'
            ];
            
            const suggestedGolfTerms = golfTerms.filter(term => 
                allText.includes(term) && 
                !customKeywords.golfFeatures.includes(term) &&
                !customKeywords.golfFeatures.some(existing => existing.toLowerCase() === term.toLowerCase())
            );

            // Feature suggestions - improved pattern matching
            const suggestedFeatures = [];
            const featurePatterns = [
                /(need|want|wish|should|could|please|add|implement|feature|function)\s+([a-z\s]+)/gi,
                /(dark mode|offline mode|apple watch|android wear|tournament mode|social features|leaderboard|voice commands|integration)/gi
            ];
            
            // Extract feature requests from patterns
            featurePatterns.forEach(pattern => {
                let match;
                while ((match = pattern.exec(allText)) !== null) {
                    const feature = match[0].toLowerCase().trim();
                    if (feature.length > 3 && 
                        !customKeywords.featureRequests.includes(feature) &&
                        !suggestedFeatures.includes(feature)) {
                        suggestedFeatures.push(feature);
                    }
                }
            });

            // Update UI with deduplicated suggestions
            updateSuggestionContainer('suggestedCompetitors', [...new Set(suggestedCompetitors)].slice(0, 10));
            updateSuggestionContainer('suggestedGolfTerms', [...new Set(suggestedGolfTerms)].slice(0, 10));
            updateSuggestionContainer('suggestedFeatures', [...new Set(suggestedFeatures)].slice(0, 10));
        }

        function updateSuggestionContainer(containerId, suggestions) {
            const container = document.getElementById(containerId);
            if (suggestions.length === 0) {
                container.innerHTML = '<p class="text-muted small">No new suggestions found</p>';
                return;
            }

            container.innerHTML = suggestions.map(suggestion => 
                `<span class="badge bg-light text-dark me-1 mb-1" style="cursor: pointer;" onclick="addSuggestion('${suggestion}', '${containerId}')">
                    ${suggestion}
                    <i class="fas fa-plus ms-1"></i>
                </span>`
            ).join('');
        }

        function addSuggestion(suggestion, containerId) {
            let category;
            switch(containerId) {
                case 'suggestedCompetitors':
                    category = 'competitors';
                    break;
                case 'suggestedGolfTerms':
                    category = 'golfFeatures';
                    break;
                case 'suggestedFeatures':
                    category = 'featureRequests';
                    break;
            }
            
            if (category && !customKeywords[category].includes(suggestion.toLowerCase())) {
                customKeywords[category].push(suggestion.toLowerCase());
                saveToStorage();
                loadKeywordsManager();
                
                // Update filters in Feedbacks List tab
                updateKeywordFilters();
            }
        }


        // Calculate keyword frequencies from all reviews
        function calculateKeywordFrequencies() {
            const frequencies = {};
            const allManagedKeywords = [
                ...customKeywords.competitors,
                ...customKeywords.golfFeatures,
                ...customKeywords.featureRequests
            ];
            
            allReviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                allManagedKeywords.forEach(keyword => {
                    if (content.includes(keyword.toLowerCase())) {
                        frequencies[keyword.toLowerCase()] = (frequencies[keyword.toLowerCase()] || 0) + 1;
                    }
                });
            });
            
            return frequencies;
        }

        // Update pain points analysis
        function updatePainPointsAnalysis() {
            if (allReviews.length === 0) {
                document.getElementById('criticalPainPoints').innerHTML = '<p class="text-muted small">Upload reviews to analyze pain points</p>';
                document.getElementById('featurePainPoints').innerHTML = '<p class="text-muted small">Upload reviews to analyze pain points</p>';
                document.getElementById('performancePainPoints').innerHTML = '<p class="text-muted small">Upload reviews to analyze pain points</p>';
                document.getElementById('uxPainPoints').innerHTML = '<p class="text-muted small">Upload reviews to analyze pain points</p>';
                return;
            }

            const painPoints = analyzePainPoints(allReviews);
            
            // Update Critical Issues
            updatePainPointContainer('criticalPainPoints', painPoints.critical, 'danger');
            
            // Update Feature Problems
            updatePainPointContainer('featurePainPoints', painPoints.features, 'warning');
            
            // Update Performance Issues
            updatePainPointContainer('performancePainPoints', painPoints.performance, 'info');
            
            // Update UX Issues
            updatePainPointContainer('uxPainPoints', painPoints.ux, 'secondary');
        }

        // Analyze pain points from reviews
        function analyzePainPoints(reviews) {
            const painPoints = {
                critical: {},
                features: {},
                performance: {},
                ux: {}
            };

            // Define pain point patterns
            const criticalPatterns = [
                /(crash|crashing|broken|not working|doesn't work|failed|failure|error|bug)/gi,
                /(can't|cannot|unable to|impossible|useless|terrible|awful|horrible)/gi
            ];

            const featurePatterns = [
                /(gps.*?(inaccurate|wrong|off|incorrect|bad|terrible|useless))/gi,
                /(yardage.*?(wrong|inaccurate|off|incorrect|bad|terrible|useless))/gi,
                /(scorecard.*?(broken|not working|doesn't work|failed|error|bug))/gi,
                /(handicap.*?(wrong|inaccurate|incorrect|bad|terrible|useless))/gi,
                /(weather.*?(wrong|inaccurate|off|incorrect|bad|terrible|useless))/gi
            ];

            const performancePatterns = [
                /(slow|laggy|lagging|freeze|freezing|hanging|loading|timeout)/gi,
                /(battery.*?(drain|draining|dead|dies|killed))/gi,
                /(memory.*?(full|leak|leaking|running out))/gi,
                /(signal.*?(lost|losing|weak|poor|bad))/gi
            ];

            const uxPatterns = [
                /(confusing|complicated|difficult|hard to use|unintuitive|cluttered)/gi,
                /(interface.*?(bad|terrible|awful|horrible|confusing|complicated))/gi,
                /(navigation.*?(bad|terrible|awful|horrible|confusing|complicated))/gi,
                /(design.*?(bad|terrible|awful|horrible|confusing|complicated))/gi
            ];

            reviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                const rating = parseFloat(review.rating) || 0;
                
                // Only analyze negative reviews (rating <= 3) or reviews with negative sentiment
                if (rating <= 3 || content.includes('bad') || content.includes('terrible') || content.includes('awful')) {
                    
                    // Critical Issues
                    criticalPatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                painPoints.critical[key] = (painPoints.critical[key] || 0) + 1;
                            });
                        }
                    });

                    // Feature Problems
                    featurePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                painPoints.features[key] = (painPoints.features[key] || 0) + 1;
                            });
                        }
                    });

                    // Performance Issues
                    performancePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                painPoints.performance[key] = (painPoints.performance[key] || 0) + 1;
                            });
                        }
                    });

                    // UX Issues
                    uxPatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                painPoints.ux[key] = (painPoints.ux[key] || 0) + 1;
                            });
                        }
                    });
                }
            });

            return painPoints;
        }

        // Update pain point container
        function updatePainPointContainer(containerId, painPoints, badgeClass) {
            const container = document.getElementById(containerId);
            
            if (Object.keys(painPoints).length === 0) {
                container.innerHTML = '<p class="text-muted small">No pain points found in this category</p>';
                return;
            }

            // Sort by frequency and take top 10
            const sortedPainPoints = Object.entries(painPoints)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            const painPointHTML = sortedPainPoints.map(([painPoint, count]) => 
                `<span class="badge bg-${badgeClass} me-1 mb-1" title="${count} mentions">
                    ${painPoint} (${count})
                </span>`
            ).join('');

            container.innerHTML = painPointHTML;
        }

        // Update advantages analysis
        function updateAdvantagesAnalysis() {
            if (allReviews.length === 0) {
                document.getElementById('featureAdvantages').innerHTML = '<p class="text-muted small">Upload reviews to analyze advantages</p>';
                document.getElementById('performanceAdvantages').innerHTML = '<p class="text-muted small">Upload reviews to analyze advantages</p>';
                document.getElementById('uxAdvantages').innerHTML = '<p class="text-muted small">Upload reviews to analyze advantages</p>';
                document.getElementById('competitiveAdvantages').innerHTML = '<p class="text-muted small">Upload reviews to analyze advantages</p>';
                return;
            }

            const advantages = analyzeAdvantages(allReviews);
            
            // Update Feature Strengths
            updateAdvantageContainer('featureAdvantages', advantages.features, 'success');
            
            // Update Performance Strengths
            updateAdvantageContainer('performanceAdvantages', advantages.performance, 'primary');
            
            // Update UX Strengths
            updateAdvantageContainer('uxAdvantages', advantages.ux, 'info');
            
            // Update Competitive Advantages
            updateAdvantageContainer('competitiveAdvantages', advantages.competitive, 'warning');
        }

        // Analyze advantages from reviews
        function analyzeAdvantages(reviews) {
            const advantages = {
                features: {},
                performance: {},
                ux: {},
                competitive: {}
            };

            // Define advantage patterns
            const featurePatterns = [
                /(gps.*?(accurate|precise|spot on|perfect|excellent|amazing|incredible|fantastic))/gi,
                /(yardage.*?(accurate|precise|spot on|perfect|excellent|amazing|incredible|fantastic))/gi,
                /(scorecard.*?(great|excellent|amazing|incredible|fantastic|perfect|wonderful))/gi,
                /(handicap.*?(accurate|precise|spot on|perfect|excellent|amazing|incredible|fantastic))/gi,
                /(weather.*?(accurate|precise|spot on|perfect|excellent|amazing|incredible|fantastic))/gi
            ];

            const performancePatterns = [
                /(fast|quick|speedy|responsive|smooth|efficient|reliable|stable)/gi,
                /(battery.*?(good|great|excellent|amazing|incredible|fantastic|lasts long))/gi,
                /(signal.*?(strong|excellent|amazing|incredible|fantastic|perfect))/gi,
                /(loading.*?(fast|quick|speedy|instant|immediate))/gi
            ];

            const uxPatterns = [
                /(easy to use|user friendly|intuitive|simple|clear|straightforward)/gi,
                /(interface.*?(great|excellent|amazing|incredible|fantastic|perfect|beautiful))/gi,
                /(design.*?(great|excellent|amazing|incredible|fantastic|perfect|beautiful))/gi,
                /(navigation.*?(great|excellent|amazing|incredible|fantastic|perfect|smooth))/gi
            ];

            const competitivePatterns = [
                /(better than|superior to|outperforms|beats|exceeds)/gi,
                /(best.*?(golf app|app|gps|scorecard|handicap))/gi,
                /(love.*?(this app|the app|it|everything))/gi,
                /(recommend.*?(this app|the app|it|to everyone))/gi
            ];

            reviews.forEach(review => {
                const content = review.content?.toLowerCase() || '';
                const rating = parseFloat(review.rating) || 0;
                
                // Only analyze positive reviews (rating >= 4) or reviews with positive sentiment
                if (rating >= 4 || content.includes('great') || content.includes('excellent') || content.includes('amazing') || content.includes('love')) {
                    
                    // Feature Advantages
                    featurePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                advantages.features[key] = (advantages.features[key] || 0) + 1;
                            });
                        }
                    });

                    // Performance Advantages
                    performancePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                advantages.performance[key] = (advantages.performance[key] || 0) + 1;
                            });
                        }
                    });

                    // UX Advantages
                    uxPatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                advantages.ux[key] = (advantages.ux[key] || 0) + 1;
                            });
                        }
                    });

                    // Competitive Advantages
                    competitivePatterns.forEach(pattern => {
                        const matches = content.match(pattern);
                        if (matches) {
                            matches.forEach(match => {
                                const key = match.toLowerCase().trim();
                                advantages.competitive[key] = (advantages.competitive[key] || 0) + 1;
                            });
                        }
                    });
                }
            });

            return advantages;
        }



        // Update advantage container
        function updateAdvantageContainer(containerId, advantages, badgeClass) {
            const container = document.getElementById(containerId);
            
            if (Object.keys(advantages).length === 0) {
                container.innerHTML = '<p class="text-muted small">No advantages found in this category</p>';
                return;
            }

            // Sort by frequency and take top 10
            const sortedAdvantages = Object.entries(advantages)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);

            const advantageHTML = sortedAdvantages.map(([advantage, count]) => 
                `<span class="badge bg-${badgeClass} me-1 mb-1" title="${count} mentions">
                    ${advantage} (${count})
                </span>`
            ).join('');

            container.innerHTML = advantageHTML;
        }


        // Update keyword filters in Feedbacks List tab
        function updateKeywordFilters() {
            // Update keyword tags cloud
            generateKeywordTags();
            
            // Update keyword selector in Dashboard
            updateKeywordSelector(allReviews);
            
            // Update keywords cloud in Dashboard
            updateKeywordsCloud(allReviews);
            
            // Update Dashboard analytics with new keyword analysis
            updateAdvancedAnalytics(allReviews);
        }

        // Enhanced keyword extraction using custom keywords
        function extractKeywordsWithCustom(content) {
            if (!content) return [];
            
            const keywords = [];
            const contentLower = content.toLowerCase();
            
            // Check custom keywords
            Object.values(customKeywords).flat().forEach(keyword => {
                if (contentLower.includes(keyword.toLowerCase())) {
                    keywords.push(keyword);
                }
            });
            
            // Add existing keyword extraction
            const existingKeywords = extractKeywords(content);
            keywords.push(...existingKeywords);
            
            return [...new Set(keywords)]; // Remove duplicates
        }

        // Duplicate review detection
        function detectDuplicates(newReviews, existingReviews) {
            const duplicates = [];
            const unique = [];
            
            newReviews.forEach(newReview => {
                const isDuplicate = existingReviews.some(existingReview => {
                    // Check for duplicates based on content and date
                    const sameContent = newReview.content && existingReview.content && 
                                      newReview.content.toLowerCase().trim() === existingReview.content.toLowerCase().trim();
                    const sameDate = newReview.date === existingReview.date;
                    const sameAuthor = newReview.author && existingReview.author && 
                                     newReview.author.toLowerCase().trim() === existingReview.author.toLowerCase().trim();
                    
                    return sameContent || (sameDate && sameAuthor && sameContent);
                });
                
                if (isDuplicate) {
                    duplicates.push(newReview);
                } else {
                    unique.push(newReview);
                }
            });
            
            return { duplicates, unique };
        }

        // Remove duplicates from existing reviews
        function removeDuplicateReviews(reviews) {
            const seen = new Set();
            return reviews.filter(review => {
                // Create a unique key based on content, date, and author
                const key = `${review.content?.toLowerCase().trim() || ''}_${review.date || ''}_${review.author?.toLowerCase().trim() || ''}`;
                if (seen.has(key)) {
                    return false; // This is a duplicate
                }
                seen.add(key);
                return true; // This is unique
            });
        }
    </script>
</body>
</html>
